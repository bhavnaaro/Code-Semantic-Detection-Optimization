,Composite Metric,Code,Time,Space,Cyclomatic,Halstead
1,58.18747170183422,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float(""-inf"")\n\n        def postorder(root):\n            if not root:  return 0\n\n            left_val, right_val = max(0, postorder(root.left)), max(0, postorder(root.right))\n            ans = max(ans, (root.val + left_val + right_val))\n            return max((root.val + left_val), (root.val + right_val))\n\n        postorder(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.359432594799204,6.257343002559292,6,3.4545454545454546
2,12.56382572559912,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        answer =  - sys.maxsize - 1\n        def dfs(node):\n            if not node:\n                return 0\n            left_sub_tree = dfs(node.left)\n            right_sub_tree = dfs(node.right)\n            answer = max(answer , left_sub_tree + right_sub_tree + node.val)\n            return max(0 , node.val + max(left_sub_tree , right_sub_tree))\n        dfs(root)\n        return answer\n\n\n    return maxPathSum(makeTree(0,l))\n",9.256639728599401,6.257276842209757,6,4.0
3,21209.630830511145,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.202258057612193,6.311333206000482,6,3.3333333333333335
4,62.04898036999534,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",9.398064363318838,6.257334004916799,8,5.4375
5,-21.131088160854375,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.235269114469526,6.257201378481136,6,2.8333333333333335
6,-27.486038851442355,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.212762633378025,6.257196156359804,6,2.8333333333333335
7,10489.16715156822,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.33889348346457,6.2839408574865345,8,4.25
8,-76.74595650428282,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.49534863625485,6.25693278167778,6,3.4615384615384617
9,-53.90189491633053,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",9.082063520517591,6.257192564944179,6,4.230769230769231
10,-75.53263584787685,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",9.063347481874139,6.257146557337214,6,2.8333333333333335
11,4.123223392299652,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",9.363783335894421,6.257203074752438,7,4.038461538461538
12,-1.2651903118025993,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",9.316034780268382,6.257212626593933,7,3.3
13,73.63264462857799,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",9.645372595847704,6.25724292091691,6,2.769230769230769
14,-44.86094971311509,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.156755951302303,6.2571791828700905,6,3.4615384615384617
15,107.98736053043282,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.571591676117315,6.257366470962711,6,2.8333333333333335
16,-46.2026123219613,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",9.164726148898405,6.257171876073802,6,3.4545454545454546
17,27.45525391521349,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.500101493724204,6.257196065355728,6,3.4615384615384617
18,-140.45794771314598,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.259923922808177,6.2568851987325145,6,4.181818181818182
19,-42.82343660999573,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.195464319987215,6.257165498633183,11,3.235294117647059
20,-24.961502327535253,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",9.347384477537839,6.257136937391685,8,2.1818181818181817
21,21334.900758674263,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.222704588472352,6.311642538707305,6,3.3333333333333335
22,-78.70374699032355,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",9.368310022004316,6.256989746970456,8,5.4375
23,-83.19149619766746,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.359113378007736,6.256982793130067,6,2.8333333333333335
24,4.933399559162961,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.295029423766819,6.25723867048548,6,2.8333333333333335
25,10685.507961574298,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.498170217233701,6.284363638690953,8,4.25
26,-22.985369721541815,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",9.48287802458978,6.257075895458824,6,3.4615384615384617
27,48.13869707833443,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",9.533709971874476,6.257232395461106,6,4.230769230769231
28,43.387989934085326,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",9.593335348642217,6.257191207492743,6,2.8333333333333335
29,-87.94303457147431,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",9.505506576642068,6.256899287174237,7,4.038461538461538
30,21.013918738435585,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",9.60631466921945,6.257127847653695,7,3.3
31,59.052270630257894,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",9.735395254222494,6.257161853340047,6,2.769230769230769
32,-36.87938832021124,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.425078863551738,6.257068668695717,6,3.4615384615384617
33,-33.796592165302066,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.379303528417582,6.257098850737611,6,2.8333333333333335
34,-20.866368731745453,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",9.307298222191966,6.2571669252990745,6,3.4545454545454546
35,-17.02796659520382,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.58627614970164,6.25704065414837,6,3.4615384615384617
36,9.096859000010628,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",9.275933260051112,6.2572585958760305,6,4.181818181818182
37,43.56037992417803,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",9.570795943598217,6.257202639163324,11,3.235294117647059
38,54.97091989570539,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",9.573824004206307,6.257230247074929,8,2.1818181818181817
