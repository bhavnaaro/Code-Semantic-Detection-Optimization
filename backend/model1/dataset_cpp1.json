{
	"POW": [
		"n",
		[
			6.586498539404165,
			1.0,
			1,
			6.0,
			"class Solution {\npublic:\n    double myPow(double x,long long int n) {\n        return pow(x,n);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			32.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n>0) return posPow(x,n) ;\n        return negPow(x,-1LL*n);\n    }\n    \n    double posPow(double x, int n){\n        if(!n)return 1.00;  \n        double res = posPow(x,n/2) ;\n        res = res*res ;\n        if(n&1) res*= x ;\n        return res ;\n    }\n    \n    double negPow(double x, long long int n){\n        if(!n) return 1.00 ;        \n        double res = negPow(x,n/2) ;\n        res = res*res ;\n        if(n&1) res/=x ;\n        return res ;\n    }\n};\n"
		],
		[
			5.221983146004064,
			1.0,
			8,
			34.0,
			"class Solution {\npublic:\n    double calPow(double x, int n) {\n        if(n==0) return 1;\n        \n        if(n%2==0){\n            double y = calPow(x,n/2);\n            return y*y;\n        }\n        else{\n            double y = calPow(x,(n-1)/2);\n            return y*y*x;\n        }\n    }\n    \n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(x==0) return 0;\n        \n        if(n<0) {\n            if(n==INT_MIN)\n                return 1/x*calPow(1/x,INT_MAX);\n            else\n                return calPow(1/x,abs(n));\n        }\n        else return calPow(x,n);\n    }\n};\n"
		],
		[
			5.768450477494363,
			1.0,
			9,
			25.2561,
			"class Solution\n{\npublic:\n\t   double pow(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (n % 2 == 1)\n\t\t{\n\t\t\treturn x * pow(x * x, n / 2);\n\t\t}\n\t\treturn pow(x * x, n / 2); \n\t\t// 2^4 = 2^2 * 2^2 == 4^2 this logic is used here. so using the recursion it the stack will reach upto eight of logn only.\n\t}\n\tdouble pow2(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (n % 2 == -1)\n\t\t{\n\t\t\treturn pow2(x * x, n / 2) / x;\n\t\t}\n\t\treturn pow2(x * x, n / 2);\n\t}\n\tdouble myPow(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1.00000;\n\t\t}\n\n\t\tios::sync_with_stdio(0);\n\t\tios::sync_with_stdio(0);\n\t\tcin.tie(0);\n\t\tcout.tie(0);\n\t\tcout << fixed;\n\t\tcout << setprecision(5);\n\n\t\tdouble res;\n\n\t\tif (n > 0)\n\t\t{\n\t\t\tres = pow(x, n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = pow2(x, n);\n\t\t}\n\n\t\treturn res;\n\t}\n};\n"
		],
		[
			192.9982375345787,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\n    double myPow(double x, int y)\n    {\n        double temp;  \n    if(y == 0)  \n        return 1;  \n    temp = myPow(x, y / 2);  \n    if (y % 2 == 0)  \n        return temp * temp;  \n    else\n    {  \n        if(y > 0)  \n            return x * temp * temp;  \n        else\n            return (temp * temp) / x;  \n    }  \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			26.4444,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n    double temp;\n    if(n==0){\n        return 1;\n    }\n    temp = myPow(x, n/2);\n    if(n%2==0.0){\n        return temp*temp; \n    }\n    else {\n        if(n>0){\n            return x*temp*temp;\n        }\n        else {\n            return temp*temp/x;\n        }\n    }\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.1111,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n   \n        if(n == 0) {return 1;}\n         double temp = myPow(x,n/2);\n        if(n % 2 == 0)\n        {\n            return temp * temp;\n        }\n        else\n        {\n            if(n > 0)\n            {\n                return temp * temp * x;\n            }\n            else\n            {\n                return temp*temp / x;\n            }\n        }\n    }\n};\n"
		],
		[
			6.458041930781177,
			1.0,
			4,
			18.5294,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        unsigned int exp = abs( static_cast<long>( n ) );\n        double retVal = 1.0;\n        \n        double pow = x;\n        while( exp > 0 ) {\n            if( exp & 0x1 ) retVal *= pow;\n            exp = exp >> 1;\n            pow *= pow;\n        }\n        \n        return n > 0 ? retVal : 1.0 / retVal;\n    }   \n};\n\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Pow(x, n).\n// Memory Usage: 5.9 MB, less than 66.73% of C++ online submissions for Pow(x, n).\n"
		],
		[
			6.912183351754671,
			1.0,
			6,
			26.6667,
			"class Solution {\npublic:\n    double go(double a, long long b){\n        if(b==1) return a;\n        if(b==0) return 1;\n        if(b<0) return go(1/a, -1*b);\n        if(b&1) return a*go(a,b-1);\n        return go(a*a,b/2);\n    }\n    double myPow(double x, int n) {\n        double ans=1;\n        ans= go(x,n);\n        return ans;\n    }\n};\n"
		],
		[
			5.41547921358156,
			1.0,
			4,
			29.2778,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long n2 = (long)n;\n        if (n2 < 0) {n2 = -n2; x = 1/x;}\n        if (n2 == 0)\n            return 1;\n        return (n2 % 2 == 0) ? myPow(x*x, n2/2) :  myPow(x*x, n2/2)*x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			20.4545,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double res=1;\n        bool f=0;\n        if(n<0)\n            f=1;\n        while(n)\n        {\n            if(n%2)\n                res=res*x;\n            x=x*x;\n            n=n/2;\n        }\n        if(f)\n            return 1/res;\n        return res;\n    }\n};\n"
		],
		[
			5.965261357881221,
			1.0,
			6,
			28.9,
			"class Solution \n{\npublic:\n    double helper(double x,long int n)\n    {\n        if(n==0)\n        {\n            return 1;\n        }\n        if(n==1)\n        {\n            return x;\n        }\n        if(n<0)\n        {\n            return helper(1/x,-n);\n        }\n        double result=helper(x*x,n/2);\n        if(n%2)\n        {\n            result*=x;\n        }\n        return result;\n    }\n    double myPow(double x, int n) \n    {\n        return helper(x,n);\n    }\n};\n"
		],
		[
			5.327962521727577,
			1.0,
			6,
			18.5185,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n       double res = 1.0;\n       \n       // Corner case.\n       if(x == 0)\n           return res;\n       \n       bool isNeg = n < 0 ? true : false;\n       long N = abs(n); // Use long to prevent overflow when n = INT_MIN because we divide n by half.\n       \n       while(N){\n           if(N & 1)\n               res = isNeg ? res / x : res * x;\n           x = x * x;\n           N >>= 1;\n       }\n       \n       return res;\n   }\n};"
		],
		[
			6.671977431389468,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        \n        double y = myPow(x,n/2);\n        if(n%2==0){\n            \n            return y*y;\n            \n        }\n        else{\n            return n < 0 ? 1/x*y*y : x*y*y; \n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.4091,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        bool flag = n < 0;\n        double res = 1;\n        while (n != 0)\n        {\n        if (n % 2)\n            res = res * x;\n        x = x * x;\n        n /= 2;\n            \n        }\n        return flag ?1/res:res; \n    }\n    \n};\n"
		],
		[
			5.996096724096273,
			1.0,
			7,
			37.6364,
			"class Solution {\npublic:\ndouble solve(double x,long n) {\n        if(n==0) return 1.0;\n        if(n==1) return x;\n        if(n%2==0) return solve(x*x,n/2);\n        return x*solve(x*x,(n-1)/2);\n    }\n    double myPow(double x, int n) {\n        long nn=n;\n        if(n<0) nn=-nn;\n        double ans=solve(x,nn);\n        if(n<0) return 1.0/ans;\n        return ans;\n    }\n};"
		],
		[
			55.1758351221242,
			1.0,
			5,
			24.0,
			"class Solution {\npublic:\n    double thisPow(double x, int n) {\n       if(n == 0) return 1; \n       double temp = thisPow(x,n/2); \n       temp *= temp;\n       if(n%2) temp *= x; \n       return temp;\n    }\n    double myPow(double x, int n) {\n        return n < 0 ? (1/thisPow(x,n)):thisPow(x,n); \n    }\n    \n};\n"
		],
		[
			5.3742606834636675,
			1.0,
			5,
			24.2778,
			"class Solution {\npublic:\n    double myPow(double x,long long int n) {\n        double ans=1.00;\n        bool n_pos=true;\n        if(n<0)\n        {\n            n_pos=false;\n            n*=-1;\n        }\n        while(n)\n        {\n            if(n&1) ans*=x;         // if n is odd  \n            n>>=1;                    // n=n/2\n            x*=x;\n        }\n\t\tif(n_pos)                        // if n is positive\n            return ans;\n\t\treturn (1.0/ans);           // if n is  negative \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			22.6154,
			"class Solution {\npublic:\n    double myPow(double x, int n) \n    {\n        // .. corner case\n        if(n == 0)\n        {\n            return 1;\n        }\n        // .. just to quickly return\n        if(x == 1)\n        {\n            return 1;\n        }\n        \n        // For all other cases\n        \n        double result = 1;\n        \n        // Administration data to fast forward the calculation by reducing the required number of iterations by half.\n        double inc = x;\n        unsigned int inc_counter = 1;\n        \n        unsigned int n_t = std::abs(n);\n        while(n_t > 0)\n        {\n            if(n_t < inc_counter)\n            {\n                inc = x;\n                inc_counter = 1;\n            }\n            \n            result *= inc;\n            n_t -= inc_counter;\n            \n            inc *= inc;\n            inc_counter+=inc_counter;\n        }\n        \n        // final result based on sign(n)\n        return (n > 0) ? result : 1/result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			24.1111,
			"class Solution\n{\n    public:\n        double myPow(double x, int n)\n        {\n            if (n == 0)  { return 1; }\n            if (n == 1)  { return x; }\n            if (n == -1) { return 1/x; }\n            \n            double res(myPow(x, n/2));\n            return n & 1 ? (n < 0 ? 1/x : x) * res * res : res * res;\n        }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			22.117,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        if (n < 0) x = (double)1.0 / x;\n        long current_power = 1, required_power = abs(n);\n        double val = x;\n\t\t// keep squaring value till the current power is less than n, e.g. if n=28\n\t\t// x^1 -> x^2 -> x^4 -> x^8 -> x^16 (can't square it further, as 32>28)\n\t\t// since val=x^16 now, calculate x^12 in another recursive call & mult with val to get x^28\n\t\t// hence, return val * myPow(x, 28 - 16)\n        while (current_power * 2 <= required_power) {\n            val *= val;\n            current_power *= 2;\n        }\n        return val * myPow(x, required_power - current_power);\n    }\n};"
		],
		[
			6.569971240228749,
			1.0,
			5,
			29.3636,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double ans=1,k=0;\n        long n1=n;\n        if(n1<0){\n            k=1;\n            n1=-n1;\n        } \n        while(n1>=1){\n            if(n1%2!=0)\n                ans*=x;\n            x*=x;\n            n1=n1/2;\n        }\n        if(k==1)\n            return (1/ans);\n        return ans;\n    }\n};\n"
		],
		[
			6.4788505790228985,
			1.0,
			5,
			28.8,
			"class Solution {\npublic:\n\tdouble myPow(double x, int n) {\n\t\tif ( n == 0 ) return 1;\n\t\tif ( n == INT_MIN ) return myPow( x * x, n / 2);\n\t\tif (n < 0 )\n\t\t{\n\t\t\tx = 1 / x;\n\t\t\tn = -n;\n\t\t}\n\t\treturn n % 2 ? myPow( x * x, n / 2) * x : myPow( x * x, n / 2 );\n\t}\n};"
		],
		[
			8.673415413215253,
			1.0,
			4,
			26.35,
			"class Solution {\npublic:\n    double myPow(double x, long long n) {\n        if (n >= 0) {\n            if (n == 0)\n                return 1;\n            double half_power = myPow(x, n/2);\n            if (n % 2) {\n                return half_power * half_power * x;\n            } else {\n                return half_power * half_power;\n            }\n        } else {\n            return 1 / myPow(x, -n);\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			5.33333,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\nreturn pow(x,n);\n\n}\n};"
		],
		[
			6.554520469785053,
			1.0,
			7,
			24.5455,
			"/*\n    https://leetcode.com/problems/powx-n/\n    TC: O(log2n)\n*/\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        // base case\n        // +ve power\n        if(n == 0 || n == 1)\n            return n == 0 ? 1 : x;\n        // -ve power\n        if(n == -1)\n            return 1 / x;\n        \n        double power = myPow(x, n/2);\n        // if power n is even\n        if(n % 2 == 0)\n            return power * power;\n        // odd power\n        else {\n            return power * power * (n < 0 ? (1 / x) : x);\n        }\n    }\n};\n"
		],
		[
			6.087125426465262,
			1.0,
			5,
			24.5455,
			"class Solution {\npublic:\n    double myPow(double x, long long n) {\n        if(n == 0) return 1;\n\n        double result = 1;\n        long long tmp = abs(n);\n        while(tmp) {\n            if(tmp % 2 == 1) {\n                result *= x;\n                tmp -= 1;\n            } else {\n                x *= x;\n                tmp /= 2;\n            }\n        }\n        return (n > 0)? result: 1/result;\n    }\n};\n"
		],
		[
			6.791099925805276,
			1.0,
			6,
			25.5,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long time=2;\n        long nn=n;\n        nn=nn<0?-nn:nn;\n        double res=n<0?1/x:x;\n        double ans=nn&1?res:1;\n        while(time<=nn){\n            res*=res;\n            if(nn&time)ans*=res;\n            time<<=1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			25.5,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long time=2;\n        long nn=n;\n        nn=nn<0?-nn:nn;\n        double res=n<0?1/x:x;\n        double ans=nn&1?res:1;\n        while(time<=nn){\n            res*=res;\n            if(nn&time)ans*=res;\n            time<<=1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			20.25,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n\treturn n == 0 ? 1 : n == 1 ? x : n == -1 ? 1 / x : (n & 1) ? x * myPow(x, n - 1) : myPow(x * x, n / 2);\n}\n};"
		],
		[
			7.019170954743179,
			1.0,
			6,
			25.2,
			"class Solution {\npublic:\ndouble myPow(double x, int n)\n{\n\tunsigned int m = (n > 0)?n:-n;\n\n\tfor(double res = double(1);; x *= x)\n\t{\n\t\tif((m & 1) != 0)\n\t\t{\n\t\t\tres *= x;\n\t\t}\n\t\tif((m >>= 1) == 0)\n\t\t{\n\t\t\treturn (n < 0?double(1) / res:res);\n\t\t}\n\t}\n\n}\n};"
		],
		[
			5.451336359020158,
			1.0,
			4,
			19.25,
			"class Solution {\npublic:\n\n    void calcPower(double x, int n, double& acm){\n        if(n!=0){\n            acm *= x;\n            return calcPower(x,(n-1), acm);\n        }\n    }\n    double myPow(double x, int n) {\n        \n        double acm = 1;\n        \n        calcPower(x,abs(n),acm);\n        \n        double pow = ((n>=0)?acm: 1/acm);\n        \n        return pow;\n    }\n};"
		],
		[
			7.793450728864129,
			1.0,
			1,
			5.83333,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\nreturn pow(x,n); // I used power fxn library formula\n}\n};"
		],
		[
			3.8538833655060003,
			1.0,
			5,
			30.1875,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n        // T = O(log2(N)) & S = O(1)\n        double ans = 1.00000;\n       long long int a = n;\n        if(n < 0) a = -1*a;\n        while(a > 0) {\n            if(a % 2 == 1) {\n                ans = ans*x;\n                a = a-1;\n            } else {\n                x = x*x;\n                a = a/2;\n            }\n        }\n        if(n < 0) ans = (double)1.00000/(double)ans;\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.2,
			"class Solution {\npublic:\ndouble myPow(double x, int n) \n{\n\tauto out{1.0};\n\tfor( ; n; out *= n&1 ? (n>0 ? x : 1.0/x) : 1.0, x *= x, n/=2);\n    return out;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			26.7188,
			"class Solution {\npublic:\ndouble myPow(double x,long long int n) {\nif(n==0)\n{ return 1;\n}\ndouble ans=1.00;\nbool n_positive=true;\nif(n<0)\n{\nn_positive=false;\nn*=-1;\n}\nwhile(n)\n{\nif(n%2==1) ans*=x;\nn=n/2;\nx*=x;\n}\nif(n_positive) // if n is positive\nreturn ans;\nreturn (1.0/ans); // if n is negative\n}\n};"
		],
		[
			6.637950424489542,
			1.0,
			6,
			25.8333,
			"class Solution {\npublic:\n\ndouble myPow(double x, int n) {\n   \n    if(n == 0) return 1;\n    if(n == 1) return x;\n    if(n == -1) return 1/x;\n    \n    double res = myPow(x , n/2);\n    return (n & 1) ? (n < 0 ? 1/x : x) * res * res : res * res;\n    \n   \n}\n};"
		],
		[
			6.985140299413437,
			1.0,
			4,
			19.1667,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double res = 1;\n        while (n) {\n            if (n % 2) res = n > 0 ? res * x : res / x;\n            x = x * x;\n            n /= 2;\n        }\n        return res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			16.6111,
			"class Solution {\npublic:\n    double myPow(double x, int n, double res = 1) {\n        return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			8,
			21.4145,
			"class Solution {\npublic:\n\n    double myPow(double x, int n) {\n        // If the power is zero, then no need to proceed.\n\t\tif(n==0){\n            return 1;\n        }\n        double t=1,y=x;\n\t\t\n\t\t//Keep in mind the limit of int data type. If its exceeding the range, return 0;\n        if(n==-2147483648){\n            if(x==1){\n                return 1;\n            }\n            else if(x==-1){\n                return 1;\n            }\n            return 0;\n        }\n\t\t\n\t\t//Keep the absolute power stored in the variable\n        int ti=abs(n);\n        \n\t\t/* Now this step is easy. All you have to do is square the y part, and divide the power by half.\n\t\tDo this while the power is greater than 1. If the power is even, divide by 2. Else reduce it by one and multiply \n\t\tthe remaining integer in any other variable, as Explained above.*/\n        while(ti>1){\n            if(ti%2==0){\n                y*=y;\n                ti/=2;\n            }\n            else{\n                t*=y;\n                ti-=1;\n            }\n        }\n\t\t\n\t\t//Multiply the storing part with the answer.\n        y*=t;\n\t\t//Check if n is positive or negative. If negative, then we need to divide it by 1.\n        if(n < 0){\n            return 1/y;\n        }\n\t\t//Return the Answer\n        return y;\n    }\n};"
		],
		[
			63.610763320533074,
			1.0,
			4,
			18.0,
			"class Solution {\npublic:\ndouble myPow(double x, int n) \n{\n\tauto out{1.0};\n\tfor( ; n; n/=2)\n    {\n\t\tif(n&1) out *= n>0 ? x : 1.0/x;\n        x *= x;\n    }\n\t\n    return out;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			23.8,
			"class Solution {\npublic:\ndouble square(double x)\n{\n    return x*x;\n}\n\ndouble myPow(double x, int n) \n{\n\tif(n<0)\n\t\tif(n!=INT_MIN)\n\t\t{\n\t\t   x = 1.0/x;\n\t\t   n = -n;\n\t\t}\n\t\telse\n\t\t\treturn square(myPow(x, n/2));\n\t\t\n\tauto out{1.0};        \n\tfor(int m{1<<30}; m; m/=2)\n\t{\n\t\tout *= out;                \n\t\tif(m&n) out *= x;\n\t}\n\n\treturn out;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			24.0,
			"class Solution\n{\npublic:\n    double myPow(double x, int n)\n    {\n        double result;\n        if (n == 0)\n        {\n            return 1;\n        }\n        result = myPow(x, n / 2);\n        if (n % 2 == 0)\n        {\n            return result * result;\n        }\n        else {\n            return n > 0 ? x * result * result  : result * result / x;\n        }\n    }\n};\n\n"
		],
		[
			5.936960385920316,
			1.0,
			4,
			29.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n == 0)  return 1;\n        if(n % 2) {\n            if(n < 0)   return myPow(x, n+1) / x;\n            else    return myPow(x, n-1) * x;\n        }\n        \n        double next = myPow(x, n/2);\n        return next*next;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n    double t;\n    if(n == 0){\n        return 1;\n    }\n    t = myPow(x, n/2);\n    if(n % 2 == 0){\n        return t * t; \n    }\n    else{\n        if(n > 0){\n            return x * t * t;\n        }\n        else {\n            return t * t / x;\n        }\n    }        \n}\n};\n"
		],
		[
			6.320145568643188,
			1.0,
			5,
			29.2917,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        \n        long long nn=n;\n        if (nn<0){\n            nn=-1*nn;\n        }\n        \n        double ans=1.0;\n        while(nn){\n            \n            //odd\n            if(nn%2){\n                \n                ans*=x;\n                nn=nn-1;\n                \n            }else{\n                //even\n                nn=nn/2;\n                x=x*x;\n            }\n        }\n        \n        if(n<0){\n            return (double)1.0/(double) ans;\n        }\n        return ans;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			25.6,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {        \n\tif(n==0) return 1;\n\tif(n<0 && n != INT_MIN)\n\t{\n\t\tn = -n;\n\t\tx = 1/x;\n\t}\n\n\treturn n%2==0 ? myPow(x*x, n/2) : x * myPow(x*x, n/2);\n }\n};"
		]
	],
	"SQRT": [
		"1",
		[
			1.0,
			1.0,
			6,
			26.9091,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1)\n            return x;\n        int ans;\n        int start =1;\n        int end =x;\n        while(start<=end){\n            int mid = start + (end-start)/2;\n            \n            if(mid == x/mid)\n                return mid;\n            else if( mid < x/mid){\n                ans = mid;\n                start = mid+1;\n            }\n            else\n                end = mid-1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			10.2143,
			"class Solution {\npublic:\n    int mySqrt(int x) {    \n        auto i = 1;\n        while (x / i > i) i++;\n        return x / i;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			30.6111,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long long l = 1, r = x;\n        while(l <= r){\n            long long m = (l + r) / 2;\n            if (m == x / m) return m;\n            else if (m * m > x) r = m - 1;\n            else l = m + 1;\n        }\n        return l - 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			19.3333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int left = 0, right = x, ans;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (1LL * mid * mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else\n                right = mid - 1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			25.65,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1)\n            return x;\n        if(x==2)\n            return 1;\n        long l=1, r=x/2+1; // square root of x will always be smaller then (x/2+1)\n        long ans = -1;\n        while(l<=r) {\n            long mid = l+(r-l)/2;\n            if(mid*mid==x) // x is perfect square so we return the mid\n                return (int)mid;\n            else if(mid*mid<x) {\n\t\t\t\tans = mid;    // if x is not perfect square, then answer will be the last number whose\n\t\t\t\t\t\t\t// square is less then x\n                l=mid+1;\n            }\n            else\n                r=mid-1;\n        }\n        return (int)ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			31.5,
			"class Solution {\npublic:\n    unsigned long long mySqrt(unsigned long long x)\n    {\n        unsigned long long l = 0;\n        unsigned long long r = x;\n        unsigned long long m, ans = 0;\n\n        if (x <= 1) {\n            return x;\n        }\n\n        while (l<=r) {\n            m = l + (r - l) / 2;\n\n            if (m * m == x) {\n                return m;\n            }\n            else if (m * m < x) {\n                ans = m;\n                l = m+1;\n            }\n            else {\n                r = m-1;\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			19.9565,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int low = 1, high = x;    \n        while(low <= high)\n        {\n            int mid = low + (high - low)/2;\n            if(pow(mid, 2) == x)\n                return mid;\n            if(pow(mid, 2) < x)\n                low = mid + 1;\n            if(pow(mid, 2) > x)\n                high = mid - 1;\n        }\n\t\treturn low-1; //if the loop terminates, the value before with decimal places would have been the sq root\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			21.25,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if (x == 1)\n            return 1;\n        \n        double result = x / 2, prev = 0;\n        while (abs(result - prev) > 0.1)\n        {\n            prev = result;\n            result = (result + x / result) / 2;\n        }\n        \n        return int(result);\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			22.1739,
			"class Solution {\npublic:\n\tint mySqrt(int x) {\n\t\tif (x < 2) return x;\n\t\t\n\t\tuint64_t mult = 0;\n\t\tint count = 0;\n\t\t\n\t\t//have mult start with half the bits of the other, if that's 0 or odd, then +1 bits\n\t\twhile ((x >> (31 - count) & 1u) == 0) count++;\n\t\tcount = (32 - count)/2 - ((count+1) % 2);\n\t\t\n\t\t//set all mult bits to 1 from count to beginning\n\t\tmult |= (~(0u) >> (31 - count));\n\n\t\t//while mult is greater, set smaller bits to 0\n\t\twhile (mult * mult > x && count > 0) {\n\t\t\tcount--;\n\t\t\tmult ^= (1u << count);\n\t\t\t\n\t\t\t//mult^2 is less than x but has too large of a difference, reset bit back to 1\n\t\t\tif (mult * mult + (mult * 2) < x) mult |= (1u << count);\n\t\t}\n\t\treturn mult;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			5,
			30.6,
			"class Solution {\npublic:\n    int util(int x, int low, int high){\n        \n        while(low < high){\n            int mid = low + (high-low)/2;\n            if((long)mid*mid < x){\n                low = mid+1;\n            }else{\n                high = mid;\n            } \n        }\n        return (long)low*low > x ? low-1 : low;\n        \n    }\n    \n    int mySqrt(int x) {\n     \n        \n        return util(x, 1, x/2);\n    }\n};"
		],
		[
			1.0,
			1.0,
			8,
			39.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==1) return 1;\n        int l=0, r=x/2;\n        while(l<r) {\n            long m=l+(r-l)/2;\n            if(m*m==x||m*m<x&&(m+1)*(m+1)>x)\n                return m;\n            if(m*m>x)\n                r=m-1;\n            if(m*m<x)\n                l=m+1;\n        }\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			28.5909,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if (x==0 || x==1)\n            return x;\n        int l=1,r=x;\n        int ans;\n        while(l<=r)\n        {\n            int mid = l + (r-l)/2;\n            \n            if(mid == x/mid)\n                return mid;\n            if(mid < x/mid)\n            {\n                l = mid+1;\n                ans = mid;\n            }\n            else\n                r = mid-1;\n        }\n        \n        return ans;\n    }\n};\n     \n"
		],
		[
			1.0,
			1.0,
			6,
			33.6818,
			"class Solution \n{\npublic:\n    int mySqrt(int x) \n\t{\n        if (x == 0 || x == 1)\n            return x;\n\t\t\t\n        int l = 1, r = (x / 2) + 1;\n        int res = 0;\n\t\t\n        while(l <= r)\n\t\t{\n            long long mid = (l + r) / 2;\n\t\t\t\n            if (mid*mid == x)\n                return mid;\t\t\n            if(mid*mid < x)\n\t\t\t{\n                l = mid + 1;\n                res = mid;\n            }\t\n            else\n                r = mid - 1;\n        }\n\t\t\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			30.7143,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==1){\n            return 1;\n        }\n        int l=0;\n        int r=x;\n        while(l<=r){\n            //cout<<l<<\" \"<<r<<endl;\n            int mid=(l+r)/2;\n            if(((long long)mid*(long long)mid)>=INT_MAX){\n                r=mid;\n                continue;\n            }\n            if(mid*mid==x){\n                return  mid;\n            }else if(mid*mid>x){\n                r=mid;\n            }else{\n                l=mid;\n            }\n            if(r==l+1){\n                return l;\n            }\n        }\n        \n        return x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n     return sqrt(x);   \n    }\n};"
		],
		[
			1.0,
			1.0,
			2,
			7.94444,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if(x<=0) return 0;\n       return pow(2,0.5*log2(x)) ;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.5455,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0)return 0;\n        int strt = 1, end=x, ans;\n        while(strt <= end){\n            int mid = strt + (end-strt)/2;\n            if(mid <= x/mid){\n                ans = mid;\n                strt = mid+1;\n            }\n            else{\n                end = mid-1;\n            }\n        }\n        return ans;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.4688,
			"/*\n    https://leetcode.com/problems/sqrtx/submissions/\n    \n    We use binary search for this. We set the lower limit as 0 and upper limit as n/2.\n    n/2 ensures that the range covers all possible candidates for sq root, since sq root is\n    m * m, so n/2 * n/2 > n and hence covers all.\n    \n    TC: O(logn)\n*/\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x <= 1)\n            return x;\n        int low = 0, high = ceil(x / 2);\n        \n        while(low < high) {\n            // rounded ceil\n            int mid = low + (high - low + 1) / 2;\n            long long sq = (long long)mid * mid;\n            if(sq <= x)\n                low = mid;\n            else\n                high = mid - 1;\n        }\n        \n        return low;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			29.45,
			"class Solution {\npublic:\nint mySqrt(int x) {\n\tlong long start = 1, end = x;\n\twhile (start <= end) {\n\t\tlong long mid = start + (end - start) / 2;\n\t\tlong long res = mid * mid;\n\t\tif (res == x)\n\t\t\treturn mid;\n\t\tif (res > x)\n\t\t\tend = mid - 1;\n\t\telse\n\t\t\tstart = mid + 1;\n\t}\n\treturn start - 1;\n}\n};"
		],
		[
			1.0,
			1.0,
			7,
			27.0375,
			"class Solution {\npublic:\n    int mySqrt(int x)\n    {\n        long long int low = 1, high = x;\n        // 1 and 0 are square roots of itself\n        if(x == 0 || x == 1)\n            return x;\n        \n        // Binary Search\n        while(low < high)\n        {\n            // mid point\n            long long int mid = (low+high+1)/2;\n            // if square of mid is less or equal but sq. of mid+1 is larger then we return smaller one\n            // x= 8; 2*2 <= 8 but 3*3 > 8, hence 2 is the answer\n            if(mid*mid <= x && (mid+1)*(mid+1) > x)\n                return mid;\n            // square of mid is larger so right subarray is removed\n            if(mid*mid > x)\n                high = mid - 1;\n            // square of mid is smaller so left subarray is removed\n            else\n                low = mid + 1;\n        }\n        return low;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			34.8333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long long mid,left= 1, right= x;\n        if(x<2)\n            return x;\n        while(left<right){\n            mid = left+(right-left)/2;\n            if(mid*mid== x)\n                return mid;\n            if(mid*mid > x){\n                right = mid;\n            }\n            else\n                left = mid+1;\n        }\n        return left-1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			35.15,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0) return 0;\n        if(x<4) return 1;\n        int ans;\n        for(long long int i=2; i<=x/2+1; i++) {\n            if(i*i==x || i+1<=x/2+1 && (i*i<x && (i+1)*(i+1)>x)) {\n                ans= i;\n                break;\n            }\n        }\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			38.5,
			"class Solution {\npublic:\nint mySqrt(int x) {\n\t\tif (x <= 0)\n\t\t\treturn 0;\n\t\tvector<int> num;\n\t\twhile (x) {\n\t\t\tnum.push_back(x%100);\n\t\t\tx /= 100;\n\t\t}\n\n\t\tint result = 0;\n\t\tint rd = 0;\n\t\tfor (int i = num.size() - 1; i >= 0; i--) {    \n\t\t\tint j = 9;\n\t\t\tint temp = ( (rd * 10) + j) * j ;\n\n\t\t\twhile (temp > num[i]) {\n\t\t\t\tj--;\n\t\t\t\ttemp = ( (rd * 10) + j) * j ;\n\t\t\t}\n\n\t\t\tresult = result * 10 + j;\n\t\t\trd = (rd * 10 + j) ;\n\n\t\t\tint reminder = num[i] -  rd * j;\n\n\t\t\tif (i > 0) {\n\t\t\t\tnum[i-1] = reminder * 100 + num[i-1];\n\t\t\t}\n\n\t\t\trd+=j;\n\t\t}\n\t\treturn result;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			9,
			42.875,
			"class Solution {\npublic:\n    long long binarySearch(int x) {\n        long long  s=2, e=x/2+1, mid;        \n        while(s<=e) {\n            mid= s+(e-s)/2;\n            if(mid*mid==x || mid*mid<x && (mid+1)*(mid+1)>x) break;\n            else if(mid*mid>x) e=mid-1;\n            else s=mid+1;\n        }\n        return mid;\n    }\n    \n    int mySqrt(int x) {\n        if(x==0) return 0;\n        if(x<4) return 1;        \n        return binarySearch(x);\n    }\n};"
		],
		[
			1.0,
			1.0,
			1,
			4.57143,
			"class Solution {\npublic:\nint mySqrt(int x) {\nreturn pow(x, 0.5);\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7273,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x; // edge case \n        int lo = 0, hi = x/2; \n        while (lo < hi) {\n            int mid = (lo + hi + 1) >> 1; \n            if (x/mid < mid) {\n                hi = mid - 1; \n            } else {\n                lo = mid; \n            }\n        }\n        return lo; \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			20.8333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x; // edge case \n        int x0 = x/2, x1 = x0/2+1; \n        while (x1 < x0) {\n            x0 = x1; \n            x1 = (x0 + x/x0)/2; \n        }\n        return x0; \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        return sqrt(x);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			31.5,
			"class Solution {\npublic:\n    int findsqrt(int low, int high, int n){\n        if(low<=high){\n            long long int mid=low +(high-low)/2;\n            if((mid*mid)<=n && (mid+1)*(mid+1)>n) return mid;\n            else if((mid*mid)<n) return findsqrt(mid+1,high,n);\n            else return findsqrt(low,mid-1,n);\n        }\n        return low;\n    }\n    int mySqrt(int x) {\n        return findsqrt(0,x,x);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			14.2222,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        __uint128_t i = 0; \n        for ( ; i <= x; ++i) {\n            if ( (i * i) > (long long)x) \n                break;\n        }\n        \n        return i-1;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			27.9286,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) return 0;\n        if (x < 3) return 1;\n        __uint128_t init = 0;\n        __uint128_t last = x;\n        __uint128_t old_mid = 0;\n        __uint128_t mid = 0;\n        while(1) {\n            mid = (init + last) / 2;\n            if (old_mid == mid) break;\n            if (mid * mid <= x) {\n                init = mid;\n            } else {\n                last = mid;\n            }\n            old_mid = mid;\n        }\n        return (int)mid;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.3333,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        if (x < 2) {\n            return x;\n        }\n        int l = 1;\n        int r = x;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n            if (m > x / m) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        return l - 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.3182,
			"class Solution\n{\npublic:\n\nint mySqrt(int x) \n{\n    if(x == 0) return 0;\n    if(x == 1) return 1;\n    \n    double res = x/2;\n    \n    for(int k = 0; k < 20; k++)\n    {\n        res = 0.5 * (res + x/res);\n    }\n    \n    return res;\n}\n};"
		],
		[
			1.0,
			1.0,
			7,
			28.5,
			"class Solution {\npublic:\nint mySqrt(int x)\n{\n    long mid ;  // because we have to do mid*mid \n    if(x ==0 || x==1) return x;\n    \n    int i=0, j=x ;\n    while(i<j)\n    {\n        mid = (i+j)/2;\n        \n        if(mid*mid == x)  return mid;\n        else if(mid*mid < x) i = mid;\n        else j=mid;\n        \n         if(j-i==1) return i;   \n    }\n    return i;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			27.3889,
			"class Solution\n{\npublic:\n\nint mySqrt(int x) \n{\n    long int l = 1;\n    long int r = x;\n    \n    while(l <= r)\n    {\n        long int mid = (l + r) / 2;\n        \n        if(mid == x / mid)\n        {\n            return mid;\n        }\n        else if(mid < x / mid)\n        {\n            l = mid + 1;\n        }\n        else\n        {\n            r = mid - 1;\n        }\n    }\n    \n    return l - 1;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			24.1429,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        if (x < 2) {\n            return x;\n        }\n        int r = x;\n        while (r > x / r) {\n            r = r / 2 + x / r / 2;\n        }\n        return r + 1 > x / (r + 1) ? r : r + 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			6.28571,
			"class Solution {\npublic:\nint mySqrt(int x) {\nif(x==0||x==1)\nreturn x;\nreturn (int)(sqrt(x));\n}\n};"
		],
		[
			1.0,
			1.0,
			3,
			16.5455,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        int res = 0;\n        for (int mask = 1 << 15; mask != 0; mask >>= 1) {\n            int next_try = res | mask;\n            if (next_try <= x / next_try) {\n                res = next_try;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			19.3529,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        union {\n            float f;\n            int i;\n        } u;\n\n        u.f = x;\n        u.i = 0x5f375a86 - (u.i >> 1);\n\n        float f = 1 / (u.f * (1.5F - 0.5F * x * u.f * u.f));\n\n        // Once Newton method\n        f = f / 2 + x / f / 2;\n\n        int r = f;\n        return r * r > x ? r - 1 : r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			34.0,
			"class Solution {\npublic:\n    int mySqrt(int n)\n    {       \n        if (n < 2) { return n; }\n        \n        int l = 0;\n        int r = n / 2;\n        int sqrt_n = n / 2;  // initial guess\n\t\t\n        while (r - l > 1)\n        {\n            if (n / sqrt_n < sqrt_n) { r = sqrt_n; }\n            else if (n / sqrt_n > sqrt_n) { l = sqrt_n; }\n            else { return sqrt_n; }  // if (n / sqrt_n == sqrt_n)\n            sqrt_n = (r + l) / 2;    \n        }  \n        return sqrt_n;        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			16.9167,
			"class Solution\n{\npublic:\n    int mySqrt(int n)\n    {\n        if (n < 2) { return n; }\n        int root = n / 2;  // initial guess for the root of f(x) = x^2 - n \n        \n        while (n / root < root)\n        {\n            root = (root + n/root) / 2;\n        }\n        \n        return root;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			33.5714,
			"class Solution { // Binary Search - Normal\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1) return x;\n        int low(1), high(x/2);\n        while(low<=high){\n            unsigned long long mid(low+(high-low)/2);\n            if(mid*mid==x || ((mid+1)*(mid+1)>x && mid*mid<x)) return mid;\n            else if(mid*mid<x) low = mid+1;\n            else high = mid-1;\n        }\n        return -1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.7143,
			"class Solution { // Binary Search - Fastest\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1) return x;\n        int low(1), high(x/2),result(-1);\n        while(low<=high){\n            int mid(low+(high-low)/2);\n            if(mid<=x/mid){\n                result = mid;\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			13.5882,
			"class Solution { // Binary Search - Lightweight\npublic:\n    double calculateSqrt(double x, double n){\n        if(abs(x/n-n)<0.000001) return n;\n        return calculateSqrt(x,(n+x/n)/2); // better n is (n+A/n)/2\n    }\n    int mySqrt(int x) {\n        return (int)calculateSqrt(x,1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			24.4444,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n        long long int l=0,r=x,m;\n        while(l<=r) {\n            m = l + (r-l)/2;\n            if(m*m >= x) {\n                r = m-1;\n            }\n            else {\n                if((m+1)*(m+1) > x ) {\n                    return m;\n                }\n                l = m+1;\n            }\n        }\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			14.8571,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long int r = x;\n        while (pow(r, 2) > x) {\n            r = (r + x / r) / 2;\n        }\n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.5,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        return floor(sqrt(x));\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			31.35,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x <= 1) return x;\n        \n        int l = 1, r = x/2;\n        \n        while(l <= r) {\n            long long mid = (l+r)/2;\n            long long p = mid * mid;\n            \n            if(p == x) return mid;\n            \n            if(p < x) l = mid + 1;\n            \n            else r = mid - 1;\n        }\n        \n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			22.6944,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if(x==0) return 0;\n        long start=1, end=x;\n        while(start<=end)   {\n            long middle = (start+end)/2;\n            if(middle*middle==x) return middle;\n            if(middle*middle<x) start=middle+1;\n            else {end=middle-1;}\n        }\n        return start-1; //start points right next to the answer, hence, we return start-1\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			38.95,
			"class Solution {\npublic:\n\tint mySqrt(int x) {\n\t\tlong long high=x;\n\t\tlong long low=0;\n\t\tlong long mid=(high-low)/2+low;\n\t\twhile(low+1<high){\n\t\t\tmid=(high-low)/2+low;\n\t\t\tif(mid*mid==x) return mid;\n\t\t\tif(mid*mid>x){\n\t\t\t\thigh=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlow=mid;\n\t\t\t}\n\t\t}\n\t\tif(high*high<=x) return high;\n\t\tif(mid*mid<=x) return mid;\n\n\t\treturn low;\n\n\t}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7273,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long int low=0;\n        long int high=x;\n        while(low<=high){\n            long int mid=(low+high)/2;\n            long int temp=mid*mid;\n            if(temp==x) return mid;\n            else if(temp<x)low=mid+1;\n            else high=mid-1;\n        }\n        return high;        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			23.75,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int lo = 0, hi = x, res;\n        while(lo <= hi){\n            long long mi = lo + (hi-lo)/2; // to avoid overflow\n            if(mi*mi == x)\n                return mi;\n            else if(mi*mi > x)\n                hi = mi-1;\n            else{\n                lo = mi+1;\n                res = mi;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			15.75,
			"class Solution \n{\npublic:\n    int mySqrt(int x) \n    {\n        if(x==0)\n        {\n            return 0;\n        }\n        long long int ans=1;\n        for(long long int i=1;i*i<=x;i++)\n        {\n            ans=i;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			28.0,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x < 2) return x;\n        int l = x;\n        while (l > x / l) \n            l = l / 2 + x / l / 2 + (l % 2 && (x / l) % 2);\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			23.75,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int lo = 0, hi = x, res;\n        while(lo <= hi){\n            long long mi = lo + (hi-lo)/2; // to avoid overflow\n            if(mi*mi == x)\n                return mi;\n            else if(mi*mi > x)\n                hi = mi-1;\n            else{\n                lo = mi+1;\n                res = mi;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			5.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        x=(int)sqrt(x);\n        return x;\n    }\n};\n"
		]
	],
	"COUNT_ISLANDS": [
		"n^2",
		[
			17.399108047460793,
			15.219194096954732,
			10,
			43.6364,
			"class Solution {\npublic:\n    void helper(vector<vector<char>>& grid,int x,int y,int n,int m){\n        if(x<0|| x>=n || y<0 || y>=m || grid[x][y]=='0' ) return;\n        grid[x][y]='0'; //mark node as visited\n        helper(grid,x-1,y,n,m);\n        helper(grid,x+1,y,n,m);\n        helper(grid,x,y+1,n,m);\n        helper(grid,x,y-1,n,m);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size();\n        \n        for(int i=0;i<n;i++){\n            int m=grid[i].size();\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1'){\n                    ans++;\n                    helper(grid,i,j,n,m);\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			18.66116786222004,
			15.219194096954734,
			10,
			38.2609,
			"// Logic to this solution: recursively erase all found islands.\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == '1') {\n                    eraseIsland(i, j, grid);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    void eraseIsland(int i, int j, vector<vector<char>>& grid) {\n        if (0 <= i && i < grid.size() && 0 <= j && j < grid[i].size() && grid[i][j] == '1') {\n            grid[i][j] = '0';\n            eraseIsland(i - 1, j, grid);\n            eraseIsland(i, j - 1, grid);\n            eraseIsland(i + 1, j, grid);\n            eraseIsland(i, j + 1, grid);\n        }\n    }\n};\n"
		],
		[
			18.304759837107223,
			15.219194096954732,
			18,
			55.8065,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        queue<pair<int, int>> q;\n        set<pair<int, int>> vis;\n        int no_isl = 0;\n        \n        for(int row = 0; row < grid.size(); row++)\n        {\n            for(int col = 0; col < grid[row].size(); col++)\n            {\n                if(grid[row][col] == '1' && vis.find({row, col}) == vis.end())\n                {\n                    q.push({row, col});\n                    vis.insert({row, col});\n                    while(!q.empty())\n                    {\n                        pair<int, int> front = q.front();\n                        q.pop();\n                        int r = front.first, c = front.second, rsize = grid.size(), csize = grid[row].size();\n                        \n                        if(c+1 < csize && grid[r][c+1] == '1' && vis.find({r, c+1}) == vis.end())\n                        {\n                            q.push({r, c+1});\n                            vis.insert({r, c+1});\n                        }\n                        if(r+1 < rsize && grid[r+1][c] == '1' && vis.find({r+1, c}) == vis.end())\n                        {\n                            q.push({r+1,c});\n                            vis.insert({r+1, c});\n                        }\n                        if(c-1 >= 0 && grid[r][c-1] == '1' && vis.find({r,c-1}) == vis.end())\n                        {\n                            q.push({r, c-1});\n                            vis.insert({r, c-1});\n                        }\n                        if(r-1 >= 0 && grid[r-1][c] == '1' && vis.find({r-1, c}) == vis.end())\n                        {\n                            q.push({r-1,c});\n                            vis.insert({r-1, c});\n                        }   \n                    }\n                    no_isl += 1;\n                }\n            }\n        }\n        return no_isl;\n    }\n};\n"
		],
		[
			20.355967865750422,
			17.87672794258763,
			21,
			56.9032,
			"class Solution {\npublic:\n    vector<int> parent,size;\n    int dis[5]={1,0,-1,0,1};\n    int cou;\n    int find_set(int v)\n    {\n        if(parent[v]==v) return v;\n        return parent[v]=find_set(parent[v]);\n    }\n    void make_set(int v)\n    {\n        parent[v]=v;\n        size[v]=1;\n    }\n    void union_set(int a,int b)\n    {\n        a=find_set(a);\n        b=find_set(b);\n        if(a!=b) \n        {cou--;\n         if(a<b) swap(a,b);\n         parent[b]=a;\n         size[a]+=size[b];\n        }\n            \n    }\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int n=grid.size(),m=grid[0].size();\n        parent.resize(n*m);\n        size.resize(n*m,0);\n        for(int i=0;i<grid.size();i++)\n            for(int j=0;j<grid[0].size();j++)\n                if(grid[i][j]=='1')\n                {   \n                    cou++;\n                    make_set(i*m+j);\n                }\n        for(int i=0;i<grid.size();i++)\n            for(int j=0;j<grid[0].size();j++)\n                if(grid[i][j]=='1')\n                {  \n                 for(int k=0;k<4;k++)\n                 {\n                     int dx=i+dis[k],dy=j+dis[k+1];\n                     if(dx>=0&&dx<n&&dy>=0&&dy<m&&grid[dx][dy]=='1')\n                         union_set(i*m+j,dx*m+dy);\n                 }\n                }\n        return cou;\n    }\n};\n"
		],
		[
			17.561320395298882,
			15.219194096954734,
			11,
			53.6471,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid,int i,int j,int r,int c)\n    {   if(i<0||j<0||i>=r||j>=c||grid[i][j]!='1') return;\n        grid[i][j]='2';\n        dfs(grid,i-1,j,r,c);\n        dfs(grid,i+1,j,r,c);\n        dfs(grid,i,j-1,r,c);\n        dfs(grid,i,j+1,r,c);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int r=grid.size();\n        if(grid.size()==0)\n            return 0;\n        int c=grid[0].size();\n        int ans=0;\n        for(int i=0;i<r;i++)\n        {  for(int j=0;j<c;j++)\n            {   if(grid[i][j]=='1')\n                {   dfs(grid,i,j,r,c);\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			17.499211944681434,
			15.219194096954734,
			12,
			46.1087,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>> &g, int r, int c, int &m, int &n, int *dr, int*dc){\n        g[r][c]='0';\n        for(int i=0; i<4; i++){\n            int rr = r+dr[i];\n            int cc = c+dc[i];\n            \n            if(rr<0||rr>=m||cc<0||cc>=n||g[rr][cc]=='0') continue;\n            \n            dfs(g, rr, cc, m, n, dr, dc);\n        }\n    }\n    \n    \n    int numIslands(vector<vector<char>>& g) {\n        int m=g.size();\n        int n=m?g[0].size():0;\n        \n        int count=0;\n        \n        int dr[] = {0,0,1,-1};\n        int dc[] = {1,-1,0,0};\n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(g[i][j]=='1'){\n                    count++;\n                    dfs(g, i, j, m, n, dr, dc);\n                }\n            }\n        }\n        return count;\n    }\n};\n"
		],
		[
			18.170008602946744,
			15.219194096954734,
			11,
			52.5667,
			"class Solution {\npublic:\n    void getnumislands(vector<vector<char>>& grid, int i, int j)\n    {\n        if(i<0 || i>=grid.size()) return;\n        if(j<0 || j>=grid[0].size()) return;\n        if(grid[i][j]=='0' || grid[i][j]=='2') return;\n            \n        grid[i][j]='2';\n        \n        getnumislands(grid,i+1,j);\n        getnumislands(grid,i,j+1);\n        getnumislands(grid,i-1,j);\n        getnumislands(grid,i,j-1);\n        \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int count=0;\n        \n        for(int i=0; i<grid.size(); i++)\n        {\n            for(int j=0; j<grid[0].size(); j++)\n            {\n                if(grid[i][j]=='1')\n                {\n                    getnumislands(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n"
		],
		[
			18.413327542786856,
			15.219194096954734,
			9,
			37.2727,
			"class Solution {\nprivate:\n    const vector<vector<int>> DIR {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    \n    bool isSafe(const vector<vector<char>>& grid, int x, int y) {\n        return x >= 0 and x < grid.size() and y >= 0 and y < grid[0].size() and grid[x][y] == '1';\n    }\n    \n    void markBfs(vector<vector<char>>& grid, int x, int y) {\n        queue<array<int, 2>> q;\n        q.push({x, y});\n        while (!q.empty()) {\n            auto current = q.front(); q.pop();\n            for (const vector<int>& d : DIR) {\n                int i = d[0] + current[0];\n                int j = d[1] + current[1];\n                if (isSafe(grid, i, j)) {\n                    grid[i][j] = '0';\n                    q.push({i, j});\n                }\n            }\n        }\n    }\n    \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int islands = 0;\n        for (int i=0; i<grid.size(); i++) {\n            for (int j=0; j<grid[0].size(); j++) {\n                if (grid[i][j] == '1') {\n                    markBfs(grid, i, j);\n                    islands++;\n                }\n            }\n        }\n        return islands;\n    }\n};\n"
		],
		[
			17.80750166965936,
			16.98649012586746,
			14,
			48.0,
			"class Solution {\n    int c=0;\n    int x[4]={-1,0,1,0};\n    int y[4]={0,1,0,-1};\npublic:\n    void dfs(vector<vector<char> > &gr,int i,int j,int m,int n,vector<vector<int> > &vis){\n        vis[i][j]=1;\n        for(int dir=0;dir<4;dir++){\n            int xd=i+x[dir];\n            int yd=j+y[dir];\n            if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\n                if(!vis[xd][yd] && gr[xd][yd]=='1'){\n                    dfs(gr,xd,yd,m,n,vis);\n                }\n            }\n        }\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int m=grid.size();\n        if(m==0) return 0;\n        int n=grid[0].size();\n        vector<vector<int> > visi(m+1,vector<int>(n+1,0));\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]=='1' && !visi[i][j]){\n                    c++;\n                    dfs(grid,i,j,m,n,visi);\n                }\n            }\n        }\n        return c;\n    }\n};\n"
		],
		[
			16.716281784362575,
			15.307066869085832,
			14,
			42.2308,
			"class Solution {\npublic:\n    int x[4] = {-1, 0, 1, 0};\n    int y[4] = {0, 1, 0, -1};\n\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == '0') return;\n        visited[i][j] = true;\n        for (int k=0; k<4; k++) {\n            dfs(i+x[k], j+y[k], grid, visited);\n        }\n    }\n\n    int ff(vector<vector<char>>& grid) {\n        if (!grid.size()) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        int count = 0;\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid[i][j] == '1' and !visited[i][j]) {\n                    dfs(i, j, grid, visited);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        return ff(grid);\n    }\n};\n"
		],
		[
			17.456014633012057,
			15.219194096954734,
			11,
			31.6667,
			"#define fastIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nclass Solution {\npublic:\nint r,c;\nint isl=0;\nvoid markcurr(vector<vector<char>>& grid , int x,int y){\n    if(x<0 || x>=r || y<0 || y>=c || grid[x][y]!='1')return ;\n    grid[x][y]='2';\n    \n    markcurr(grid,x+1,y);\n    markcurr(grid,x-1,y);\n    markcurr(grid,x,y+1);\n    markcurr(grid,x,y-1);\n}\nint numIslands(vector<vector<char>>& grid) {\n    fastIO;\n    r=grid.size();\n    if(r==0)return 0;\n    c=grid[0].size();\n    \n    for(int i=0;i<r;++i)\n        for(int j=0;j<c;++j)\n            if(grid[i][j]=='1')\n                {markcurr(grid,i,j);\n                isl++;}\n                \n    return isl;\n}\n};"
		],
		[
			17.608251101390596,
			15.219194096954734,
			11,
			45.5,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>> &grid, int row, int col){\n        int ROWS = grid.size();\n        int COLS = grid[0].size();\n        \n        if(row>=ROWS || row<0 || col>=COLS || col<0 || grid[row][col]=='2' || grid[row][col]=='0')\n            return;\n        \n        grid[row][col] = '2';\n        \n        dfs(grid,row-1,col);\n        dfs(grid, row, col-1);\n        dfs(grid, row, col+1);\n        dfs(grid, row+1, col);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        \n        int ROWS = grid.size();\n        int COLS = grid[0].size();\n        \n        int count = 0;\n        \n        for(int i=0;i<ROWS;i++){\n            for(int j=0;j<COLS;j++){\n                if(grid[i][j]=='1'){\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        \n        return count++;\n    }\n};\n"
		],
		[
			18.33361470827628,
			15.219194096954734,
			10,
			24.6774,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int island_count = 0;\n        \n\t\t// iterate through the matrix O(m x n)\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == '1') {\n\t\t\t\t\t// found an island, increment count and call sink\n                    ++island_count;\n                    sinkIsland(&grid, i, j);\n                }\n            }\n        }\n        \n        return island_count;\n    }\nprivate:\n    void sinkIsland(vector<vector<char>>* grid_ptr, int i, int j) {\n\t\t// passing by pointer to avoid using non-const references\n\t\t// this is a C++ style choice\n        auto& grid = *grid_ptr;\n        \n\t\t// if the current coordinate isn't part of the island, return\n        if (grid[i][j] != '1') return;\n        \n\t\t// sink the current coordinate\n        grid[i][j] = '0';\n        \n\t\t// if the any of the following coordinates is valid\n\t\t// call sinkIsland recursively\n\t\tif (i < grid.size() - 1) sinkIsland(grid_ptr, i + 1, j);  // east\n        if (i > 0) sinkIsland(grid_ptr, i - 1, j);  // west\n\t\tif (j < grid[i].size() - 1) sinkIsland(grid_ptr, i, j + 1);  // north\n        if (j > 0) sinkIsland(grid_ptr, i, j - 1);  // south\n    }\n};\n"
		],
		[
			21.204519951469276,
			7.444265120541342,
			17,
			56.6346,
			"class Solution {\nprivate:\n    void dfs(int i, int j, const vector<vector<char>>& grid, set<pair<int, int>>& vis, int n, int m){\n        if( (i < 0 || j < 0 || i >= n || j >= m) ) return;\n        vis.insert({i,j});\n        if(grid[i][j] == '0') return;\n        auto p = vis.find({i+1, j});\n        if(p == vis.end()){\n            dfs(i+1, j, grid, vis, n, m);\n        }\n        p = vis.find({i-1, j});\n        if(p == vis.end()){\n            dfs(i-1, j, grid, vis, n, m);\n        }\n        p = vis.find({i, j+1});\n        if(p == vis.end()){\n            dfs(i, j+1, grid, vis, n, m);\n        }\n        p = vis.find({i, j-1});\n        if(p == vis.end()){\n            dfs(i, j-1, grid, vis, n, m);\n        }\n    }\n    \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size();\n        if(!n) return 0;\n        int m = grid[0].size();\n        if(!m) return 0;\n        int cnt = 0;\n        set<pair<int, int>> vis;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                auto p = vis.find({i, j});\n                if(grid[i][j] == '1' && p == vis.end()){\n                    dfs(i, j, grid, vis, n, m);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.272131846075713,
			15.219194096954734,
			13,
			38.6207,
			"class Solution {\npublic:\n    void recur(vector<vector<char>>& grid, int row, int col) {\n        grid[row][col] = '2'; // Visisted so mark to '2'\n        if (row-1 >= 0 && grid[row-1][col] == '1') recur(grid, row-1, col);\n        if (col-1 >= 0 && grid[row][col-1] == '1') recur(grid, row, col-1);\n        if (row+1 < grid.size() && grid[row+1][col] == '1') recur(grid, row+1, col);\n        if (col+1 < grid[0].size() && grid[row][col+1] == '1') recur(grid, row, col+1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for (int i = 0; i<grid.size(); i++) {\n            for (int j = 0; j<grid[0].size(); j++) {\n                if (grid[i][j] == '1') { // Found a land, find the region by recursion\n                    recur(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};"
		],
		[
			17.5312080078524,
			15.219194096954734,
			14,
			59.8235,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>> &grid) {\n        int m = grid.size();\n        if (m==0) return 0;\n        int n = grid[0].size();\n        int count = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j]=='1') {\n                    helper(grid,i,j,m,n);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    void helper(vector<vector<char> >& a, int i, int j, int m, int n) {\n        a[i][j] = 0;\n        if (i > 0 && a[i-1][j]=='1') helper(a,i-1,j,m,n);\n        if (j > 0 && a[i][j-1]=='1') helper(a,i,j-1,m,n);\n        if (i < m-1 && a[i+1][j]=='1') helper(a,i+1,j,m,n);\n        if (j < n-1 && a[i][j+1]=='1') helper(a,i,j+1,m,n);\n    }\n};"
		],
		[
			23.023654808759616,
			17.877371165911615,
			14,
			59.7143,
			"class Solution {\npublic:\n    struct Point {\n        int row, col;\n        Point(int _x, int _y) : row(_x), col(_y) {}\n    };\n    int nr_row, nr_col;\n    int numIslands(vector<vector<char> > &grid) {\n        if (grid.empty() || grid[0].empty()) {\n            return 0;\n        }\n\n        nr_row = grid.size();\n        nr_col = grid[0].size();\n\n        int res = 0;\n        queue<Point> q;\n        \n        for (int i = 0; i < nr_row; ++i) {\n            for (int j = 0; j < nr_col; ++j) {\n                if (grid[i][j] == '0') {\n                    continue;\n                }\n                ++res;\n\n                grid[i][j] = '0';\n                q.push(Point(i, j));\n                while (!q.empty()) {\n                    Point point = q.front();\n                    q.pop();\n                    addNeighbor(grid, point, -1,  0, q);\n                    addNeighbor(grid, point,  0, -1, q);\n                    addNeighbor(grid, point,  1,  0, q);\n                    addNeighbor(grid, point,  0,  1, q);\n                }\n            }\n        }\n        return res;\n    }\n\n    void addNeighbor(vector<vector<char> > &grid, Point point, \n            int d_row, int d_col, queue<Point> &q) {\n        point.row += d_row;\n        point.col += d_col;\n        if (point.row >= nr_row || point.col >= nr_col || \n                point.row < 0 || point.col < 0 ||\n                grid[point.row][point.col] == '0') {\n            return;\n        }\n        grid[point.row][point.col] = '0';\n\n        q.push(point);\n    }\n};"
		],
		[
			24.778549169086133,
			17.01834221306894,
			17,
			71.52,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (!grid.size() || !grid[0].size()) return 0;\n        int count = 0;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<int> queue; \n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '0' || visited[i][j]) continue;\n                count++;\n                visited[i][j] = true;\n                queue.push(i * n + j);\n                while (!queue.empty()) {\n                    int x = queue.front() / n, y = queue.front() % n;\n                    queue.pop();\n                    if (grid[x][y] == '0') continue;\n                    if (x - 1 >= 0 && !visited[x-1][y]) {queue.push((x-1) * n + y); visited[x-1][y] = true;}\n                    if (y - 1 >= 0 && !visited[x][y-1]) {queue.push(x * n + y-1); visited[x][y-1] = true;}\n                    if (x + 1 < m && !visited[x+1][y]) {queue.push((x+1) * n + y); visited[x+1][y] = true;}\n                    if (y + 1 < n && !visited[x][y+1]) {queue.push(x * n + y+1); visited[x][y+1] = true;}\n                }\n            }\n                \n        return count;           \n    }\n\n};"
		],
		[
			17.324149476727463,
			15.219194096954732,
			14,
			66.1111,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid, int rows, int cols, int i, int j) {\n        // cout << i << j << endl;\n        grid[i][j] = '0';\n        if ((i-1) >= 0 && grid[i-1][j] == '1') dfs(grid, rows, cols, i-1, j);\n        if ((i+1) < rows && grid[i+1][j] == '1') dfs(grid, rows, cols, i+1, j);\n        if ((j-1) >= 0 && grid[i][j-1] == '1') dfs(grid, rows, cols, i, j-1);\n        if ((j+1) < cols && grid[i][j+1] == '1') dfs(grid, rows, cols, i, j+1);\n        // return;\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if (!grid.size()) return 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int numberIslands = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j]=='1') {\n                    ++numberIslands;\n                    dfs(grid, rows, cols, i, j);\n                }\n            }\n        }\n        return numberIslands;\n    }\n};\n"
		],
		[
			18.262745754411572,
			15.219194096954734,
			11,
			27.9776,
			"/*\n    https://leetcode.com/problems/number-of-islands/\n    TC: O(V^2)\n*/\nclass Solution {\npublic:\n    void DFS(vector<vector<char>>& grid, int i, int j) {\n        // boundary checking\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\n            return;\n        // return if current position is of water or is already visited\n        if(grid[i][j] == '2' || grid[i][j] == '0')\n            return;\n        \n        // mark the current as visited\n        grid[i][j] = '2';\n        \n        // do DFS in all 4 directions\n        DFS(grid, i+1, j);\n        DFS(grid, i, j-1);\n        DFS(grid, i-1, j);\n        DFS(grid, i, j+1);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        // We can treat the matrix grid as a grid. Each Island is a\n        // connected component. The task is to find no. of disconnectedd components\n        // in the graph.\n        \n        int islands = 0;\n        // We make each 1 as 2 in when it is visited\n        for(int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[0].size(); j++) {\n                // do DFS in case has not been visited and there is land\n                if(grid[i][j] == '1') {\n                    DFS(grid, i, j);\n                    ++islands;\n                } \n            }\n        }\n        return islands;\n    }\n};\n"
		],
		[
			18.301664182098715,
			15.219194096954734,
			11,
			29.7759,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        //test edge cases\n        if(grid.size()==0) return 0;\n        int numIslands = 0;\n        //lets traverse the matrix now and check for every cell\n        for(int i=0; i<grid.size(); i++)\n        {\n            for(int j=0; j<grid[0].size(); j++)\n            {\n                if(grid[i][j] == '1')\n                {\n                    numIslands += dfs(grid, i, j);\n                }\n            }\n        }\n        return numIslands;\n    }\n    \n    int dfs(vector<vector<char>>& grid, int i, int j) {\n        //check the bounds of 2-d matrix\n        //it shouldn't go out of bounds i.e beyond the scope of matrix\n        //And if grid[i][j] is 0 then we don't care and only return 0\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]=='0') \n            return 0;\n        \n        //since we have visited grid[i][j] lets mark it as 0 to avoid visiting it again\n        grid[i][j]='0';\n        //now lets traverse its neighbours \n        dfs(grid, i+1, j); //down\n        dfs(grid, i-1, j); //up\n        dfs(grid, i, j+1); //right\n        dfs(grid, i, j-1); //left\n        return 1;\n    }    \n};\n"
		],
		[
			17.50587165451414,
			15.219194096954734,
			11,
			42.5,
			"class Solution {\npublic:\n\tint m;\n\tint n;\n\tvoid fill(vector<vector<char>>& grid,int x,int y){\n\t\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]=='0'){\n\t\t\treturn;\n\t\t}\n\t\tgrid[x][y]='0';\n\t\tfill(grid,x+1,y);\n\t\tfill(grid,x-1,y);\n\t\tfill(grid,x,y+1);\n\t\tfill(grid,x,y-1);\n\t}\n\tint numIslands(vector<vector<char>>& grid) {\n\t\tif(grid.empty()) return 0;\n\t\tm=grid.size();\n\t\tn=grid[0].size();\n\t\tint res=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(grid[i][j]=='1'){\n\t\t\t\t\tres++;\n\t\t\t\t\tfill(grid,i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\n\t}\n};"
		],
		[
			26.48074819188916,
			18.504947090861318,
			29,
			90.3409,
			"class Solution {\npublic:\n    #include<vector>\n    class UnionFind{\npublic:\n    int n, m;   \n    vector < vector <int> > size;\n    vector <vector <pair <int, int> > > parent;\n    vector < vector <bool> > cross;\n    int numofcomponents;\n    UnionFind(int n, int m) {\n        this->n = n;\n        this->m = m;\n        size.assign(n, vector <int> (m, 1));\n        cross.assign(n, vector <bool> (m, true));\n        parent.assign(n, vector <pair <int, int> > (m, {-1, -1}));\n        for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) {parent[i][j] = {i, j};} }\n        numofcomponents = n*m;\n    }\n\n    pair <int, int> find(pair <int, int> p) {\n        pair <int, int> root = p;\n        while (root != parent[root.first][root.second]) {\n            root =  parent[root.first][root.second];\n        }\n        // Armortized Algorithm\n        while (p != root) {\n            pair <int, int> next = parent[p.first][p.second];\n            parent[p.first][p.second] = root;\n            p = next;\n        }\n        return root;\n    }\n\n    bool isConnected(pair <int, int> p, pair <int, int> q) {\n        return find(p) == find(q);\n    }\n\n    int componentsize(pair <int, int> p ) {\n        pair <int, int> temp = find(p);\n        return size[temp.first][temp.second];\n    }\n\n    int commponents() {\n        return numofcomponents;\n    }\n\n    void unify(pair <int, int> p, pair <int, int> q) {\n        pair <int, int> root1 = find(p);\n        pair <int, int> root2 = find(q);\n        if (root1 == root2) return;\n        if (size[root1.first][root1.second] > size[root2.first][root2.second]) {\n            size[root1.first][root1.second] += size[root2.first][root2.second];\n            parent[root2.first][root2.second] = root1;\n        } else {\n            size[root2.first][root2.second] += size[root1.first][root2.second];\n            parent[root1.first][root1.second] = root2;\n        }\n\n        numofcomponents--;\n    }\n};\n    int numIslands(vector<vector<char>>& grid) {\n         int n = grid.size();\n        if (n == 0)return 0;\n        int zeros = 0;\n        int m = grid[0].size();\n        UnionFind U(n, m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == '0') {\n                    zeros++;\n                    continue;\n                }\n                if (i != 0) {\n                    if (grid[i][j] == grid[i - 1][j])\n                    U.unify({i, j},{i - 1, j});\n                }\n                if (j != 0) {\n                     if (grid[i][j] == grid[i][j - 1])\n                    U.unify({i, j}, {i, j - 1});\n                }\n                if (i != n - 1) {\n                    if (grid[i][j] == grid[i + 1][j])\n                    U.unify({i, j}, {i + 1, j});\n                }\n                if (j != m - 1) {\n                     if (grid[i][j] == grid[i][j + 1])\n                    U.unify({i, j}, {i, j + 1});\n                }\n                if (i == 0 || j == 0 || i == n - 1 || j == m-1) {\n                    pair <int, int> tmp = U.find({i, j});\n                    U.cross[tmp.first][tmp.second] = false;\n                }\n               \n            }\n        }\n        return U.numofcomponents - zeros;\n\n    }\n};\n\n"
		],
		[
			18.357257736684076,
			15.219194096954734,
			11,
			24.5455,
			"class Solution {\n    void sinkIsland(int x, int y, vector<vector<char>>& grid) {\n        if (x < 0 || y < 0 || x == grid.size()  || y == grid[0].size()) return; // Return if we are out of bounds\n        if (grid[x][y] == '0') return; // return if we hit the ocean\n        grid[x][y] = '0'; // Otherwise, we didn't hit the ocean, time to sink the island\n        sinkIsland(x + 1, y, grid); // Go down one \n        sinkIsland(x - 1, y, grid); // Go up one\n        sinkIsland(x, y + 1, grid);  // Go right one\n        sinkIsland(x, y - 1, grid); // go left one.\n        return; // Island is sunk. Return to main function.\n    }\n      \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int cnt{};\n        if (grid.empty()) return 0;\n        for (int i{}; i < grid.size(); i++) {\n            for (int j{}; j < grid[0].size(); j++) {\n                if (grid[i][j] == '1') { // If there is a 1, it's an island, lets wipe it off the map.\n                    sinkIsland(i, j, grid);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.22051957718391,
			17.876742958928283,
			14,
			78.8889,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0) return 0;\n        int row = grid.size();\n        int col = grid[0].size();\n        int flag = 0;\n        vector<vector<int>> M(row, vector<int>(col, 0));\n        vector<vector<int>> visited(row, vector<int>(col, 0));\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                if(grid[i][j] == '1' && M[i][j] == 0) {\n                    dfs(grid, M, visited, i, j, ++flag);\n                } else {\n                    continue;\n                }\n            }\n        }\n        return flag;\n    }\n    \n    void dfs(vector<vector<char>>& grid, vector<vector<int>>& M, vector<vector<int>>& visited, int i, int j, int flag) {\n        if(i < 0 || j < 0 || i == grid.size() || j == grid[0].size() || visited[i][j] == 1) {\n            return;\n        } else if(grid[i][j] == '0') {\n            visited[i][j] = 1;\n            return;\n        }\n        \n        if(grid[i][j] == '1') {\n            M[i][j] = flag;\n            visited[i][j] = 1;\n            dfs(grid, M, visited, i, j - 1, flag);\n            dfs(grid, M, visited, i - 1, j, flag);\n            dfs(grid, M, visited, i, j + 1, flag);\n            dfs(grid, M, visited, i + 1, j, flag);\n        }\n        \n        return;\n    }\n};\n"
		],
		[
			18.881175507363743,
			16.986474838193747,
			18,
			42.5714,
			"class Solution {\npublic:\nclass UnionFind {\nprivate:\n    vector<int> parent;\n\npublic:\n    int count;\n\n    UnionFind(int n) : parent(n), count(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    void uni(int p, int q) {\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if (pRoot != qRoot) {\n            parent[pRoot] = qRoot;\n            count--;\n        }\n    }\n\n    int find(int node) {\n        if (parent[node] == node) {\n            return node;\n        }\n        //path compression\n        parent[node] = find(parent[node]);\n        return parent[node];\n    }\n\n    bool connected(int p, int q) {\n        return find(p) == find(q);\n    }\n};\n    int numIslands(vector<vector<char>> &grid) {\n        if (grid.empty()) return 0;\n        int d[2][2]{{1, 0},\n                    {0, 1}};  //search right/down.\n        int m = grid.size(), n = grid[0].size(), zeros = 0;\n        UnionFind uf(m * n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] != '1') {\n                    zeros++;\n                    continue;\n                }\n                int node1 = i * n + j;\n                for (int k = 0; k < 2; k++) {\n                    int newX = i + d[k][0];\n                    int newY = j + d[k][1];\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == '1') {\n                        int node2 = newX * n + newY;\n                        uf.uni(node1, node2);\n                    }\n                }\n            }\n        }\n        return uf.count - zeros;\n    }\n};\n"
		],
		[
			18.251291366669943,
			15.219194096954732,
			10,
			45.2647,
			"class Solution {\npublic:\n    \n    void dfs(vector<vector<char>>& graph,int row,int col){\n\n    if(graph[row][col] == '1'){\n        graph[row][col] = '0';\n    if(row >=1)\n        dfs(graph,row-1,col);\n    if(row <graph.size()-1)\n        dfs(graph,row+1,col);\n    if(col >= 1)\n        dfs(graph,row,col-1);\n    if(col < graph[0].size()-1)\n        dfs(graph,row,col+1);\n    }\n\n}\n    \n    \n    int numIslands(vector<vector<char>>& grid) {\n            int ans = 0;\n    for(int i=0;i<grid.size();i++){\n        for(int j=0;j<grid[0].size();j++){\n            if(grid[i][j] == '1'){\n                dfs(grid,i,j);\n                ans++;\n            }\n        }\n    }\n    return ans;\n    }\n};\n"
		],
		[
			17.234029878531786,
			15.219194096954734,
			11,
			45.0,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.empty()) {\n            return 0;\n        }\n        int res = 0, m = grid.size(), n = grid[0].size();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    ++res;\n                    dfs(grid, i, j, m, n);\n                }\n            }\n        }\n        return res;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int r, int c, int& m, int& n) {\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == '0') {\n            return;\n        }\n        grid[r][c] = '0';\n        dfs(grid, r + 1, c, m, n);\n        dfs(grid, r - 1, c, m, n);\n        dfs(grid, r, c - 1, m, n);\n        dfs(grid, r, c + 1, m, n);\n    }\n};\n"
		],
		[
			19.46671585918455,
			17.87672794258763,
			19,
			62.6552,
			"class Solution {\npublic:\nclass UF\n{\npublic:\n\tUF(int n) :id(n), sz(n, 1), counter(n)\n\t{\n\t\tfor (int i = 0; i < n; ++i) id[i] = i;\n\t}\n\n\tvoid uni(int p, int q)\n\t{\n\t\tint i = root(p);\n\t\tint j = root(q);\n\t\tif (i != j)\n\t\t{\n\t\t\tif (sz[i] < sz[j]) {\n\t\t\t\tid[i] = j;\n\t\t\t\tsz[j] += sz[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[j] = i;\n\t\t\t\tsz[i] += sz[j];\n\t\t\t}\n\t\t\t--counter;\n\t\t}\n\t}\n\n\tint root(int i)\n\t{\n\t\twhile (i != id[i])\n\t\t{\n\t\t\tid[i] = id[id[i]];\n\t\t\ti = id[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\tbool connected(int p, int q)\n\t{\n\t\treturn root(p) == root(q);\n\t}\n\n\tint count(){\n\t\treturn counter;\n\t}\nprivate:\n\tint counter;\n\tvector<int> id;\n\tvector<int> sz;\n};\n    int numIslands(vector<vector<char>>& grid) {\n        int rows = grid.size();\n        if(rows == 0) return 0;\n        int cols = grid[0].size();\n        if(cols == 0) return 0;\n        int n = rows * cols;\n        int zeros = 0;\n        UF uf(n);\n        for(int i = 0; i < rows; ++i){\n            for(int j = 0; j < cols; ++j){\n                if(grid[i][j] == '1'){\n                    int id = i*cols + j;\n                    if(i+1<=rows-1 && grid[i+1][j] == '1'){\n                        uf.uni(id, id + cols);\n                    }\n                    if(j+1<=cols-1 && grid[i][j+1] == '1'){\n                        uf.uni(id, id + 1);\n                    }\n                }\n                else\n                {\n                    ++zeros;\n                }\n            }\n        }\n        return uf.count() - zeros;\n    }\n};"
		],
		[
			17.53274812616522,
			15.219194096954734,
			14,
			55.5882,
			"class Solution {\nprivate:\n    int row, column;\n    void traverse(vector<vector<char>>& grid, int r, int c)\n    {\n        grid[r][c] = '0';\n        if(r-1>-1 && grid[r-1][c]=='1') traverse(grid, r-1, c);\n        if(c-1>-1 && grid[r][c-1]=='1') traverse(grid, r, c-1);\n        if(r+1<row && grid[r+1][c]=='1') traverse(grid, r+1, c);\n        if(c+1<column && grid[r][c+1]=='1') traverse(grid, r, c+1); \n        \n    }\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        row=grid.size();\n        if(!row) return 0;\n        column=grid[0].size();\n        int count = 0;\n        for(int r = 0; r < row; r++)\n            for(int c = 0; c < column; c++)\n                if(grid[r][c] == '1') count++,traverse(grid, r, c);\n        return count;\n    }\n};"
		],
		[
			26.506908569306155,
			20.203928002449988,
			11,
			34.1136,
			"class Solution {\npublic:\n    bool DFS(vector<vector<char>>& grid, int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n            return false;\n        grid[i][j] = '0';\n        vector<pair<int, int>> dirs = {{-1,0}, {0,-1}, {1,0}, {0,1}};\n        for (auto dir : dirs) {\n            DFS(grid, i + dir.first, j + dir.second);\n        }\n        return true;\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int ans = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (DFS(grid, i, j))\n                    ans++;\n            }\n        }\n        return ans;\n    }\n};"
		],
		[
			18.543562054819226,
			16.986486728617333,
			14,
			56.28,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int row = grid.size();\n        if (row == 0)\n            return 0;\n        int col = grid[0].size();\n        if (col == 0)\n            return 0;\n\n        vector<vector<int>> visited(row, vector<int>(col, 0));\n        \n        int count = 0;\n        int i = 0;\n        int j = 0;\n        \n        for (i = 0; i < row; i++)\n        {\n            for (j = 0; j < col; j++)\n            {\n                if ( (visited[i][j] == 0) && (grid[i][j] == '1') )\n                {\n                    count++;\n                    dfs(grid, visited, i, j, row, col);\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    void dfs(vector<vector<char>> &grid, vector<vector<int>> &visited, int i, int j, int row, int col)\n    {\n        if (i < 0 || i >= row || j < 0 || j >= col)\n            return;\n        \n        if (grid[i][j] == '0' || visited[i][j] == 1)//water or has been visited\n            return;\n            \n        visited[i][j] = 1;\n        \n        dfs(grid, visited, i-1, j, row, col);//up\n        dfs(grid, visited, i, j+1, row, col);//right\n        dfs(grid, visited, i+1, j, row, col);//down\n        dfs(grid, visited, i, j-1, row, col);//left\n    }\n};"
		],
		[
			19.814706603328652,
			16.986474838193747,
			18,
			44.1224,
			"//number of islands\n//\u8f6c\u6362\u6210\u4e00\u7ef4id\uff0c\u5b58\u5165\u8fb9\u96c6\u5408\uff0c\u7136\u540e\u6c42\u8fde\u901a\u5206\u91cf\u7684\u4e2a\u6570\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char> >& grid) {\n        if (grid.size() == 0) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        //first convert to 1 dimension position, and convert all connections to edges\n        vector<pair<int, int> >edges;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    int id = i * n + j;\n                    //go right\n                    if (j + 1 < n) {\n                        if (grid[i][j+1] == '1') {\n                            int right = i * n + j + 1;\n                            edges.push_back(make_pair(id, right));\n                        }\n                    }\n                    //go down\n                    if (i + 1 < m) {\n                        if (grid[i+1][j] == '1') {\n                            int down = (i + 1) * n + j;\n                            edges.push_back(make_pair(id, down));\n                        }\n                    }\n                }\n            }\n        }\n        \n        //First construct the Union Find structure\n        vector<int> hashSet(m * n, 0);\n        for (int i = 0; i < m * n; i++) {\n            hashSet[i] = i;\n        }\n        \n        //Next Union Find\n        for (auto edge : edges) {\n            Union(hashSet, edge.first, edge.second);\n        }\n        \n        int numComponents = 0;\n        for (int i = 0; i < m * n; i++) {\n            if ( grid[i / n][i % n] == '1' && hashSet[i] == i)\n                numComponents++;\n        }\n        \n        return numComponents;\n    }\n    \n    void Union(vector<int>& hashSet, int first, int second) {\n        int first_father = Find(hashSet, first);\n        int second_father = Find(hashSet, second);\n        \n        if (first_father != second_father)\n            hashSet[first_father] = second_father;\n    }\n    \n    int Find(vector<int>& hashSet, int val) {\n        int parent = val;\n        while (parent != hashSet[parent]) {\n            parent = hashSet[parent];\n        }\n        return parent;\n    }\n};"
		],
		[
			18.469528045489046,
			15.219194096954734,
			11,
			49.2812,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for(int i = 0; i < grid.size(); i++)\n        {\n            for(int j = 0; j < grid[i].size(); j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    count++;\n                    depthFirstSearch(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n    \n    void depthFirstSearch(vector<vector<char>>& grid, int x, int y)\n    {\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())\n            return;\n        if (grid[x][y] == '0')\n            return;\n        if (grid[x][y] == '1')\n        {\n            grid[x][y] = '0';\n            depthFirstSearch(grid, x + 1, y);\n            depthFirstSearch(grid, x - 1, y);\n            depthFirstSearch(grid, x, y + 1);\n            depthFirstSearch(grid, x, y - 1);\n        }\n    }\n};"
		],
		[
			18.918594699036962,
			16.986474838193747,
			16,
			43.4483,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n  int N = grid.size();\n  int count = 0;\n  vector<int> parent(N ? N * grid[0].size() : 0);\n  for (int r = 0; r < grid.size(); ++r) {\n    for (int c = 0; c < grid[r].size(); ++c) {\n      if (grid[r][c] == '1') {\n        ++count;\n        int i = idx(r, c, N);\n        parent[i] = i;\n        if (r > 0 && grid[r-1][c] == '1' && doUnion(i, idx(r-1, c, N), parent))\n          --count;\n        if (c > 0 && grid[r][c-1] == '1' && doUnion(i, idx(r, c-1, N), parent))\n          --count;\n      }\n    }\n  }\n  return count;\n}\n\nbool doUnion(int x, int y, vector<int>& parent) {\n  int rootx = find(x, parent);\n  int rooty = find(y, parent);\n  if (rootx == rooty)\n      return false;\n  parent[rooty] = rootx;\n  return true;\n}\n\nint find(int x, vector<int>& parent) {\n  return (parent[x] == x) ? x : find(parent[x], parent);\n}\n\ninline int idx(int row, int col, int nrows) { return col * nrows + row; }\n};"
		],
		[
			8.925242314860563,
			15.219194096954734,
			12,
			35.625,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n    const int row = grid.size();\n    if (0 == row) return 0;\n    const int col = grid[0].size();\n    int cnt = 0;\n    for (int i = 0; i < row; i++)\n     for (int j = 0; j < col; j++) {\n         if (grid[i][j] == '1') {\n             cnt++;\n             dfs(grid, i, j);\n         }\n     }\n     return cnt;\n}\nvoid dfs(vector<vector<char>> &grid, int i, int j) {\n    if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') return;\n    grid[i][j] = '2';\n    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    for (auto dir : dirs) dfs(grid, i + dir.first, j + dir.second);\n}\n};"
		],
		[
			18.477396247312658,
			15.219194096954734,
			10,
			53.6071,
			"class Solution {\npublic:\nvoid DFS(vector<vector<char>>& grid, int i, int j){\n\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\n\t    if('0' == grid[i][j]) return;\n\t    grid[i][j] = '0';\n\t    DFS(grid, i-1, j);\n\t    DFS(grid, i+1, j);\n\t    DFS(grid, i, j - 1);\n\t    DFS(grid, i, j + 1);\n\t}\n\tint numIslands(vector<vector<char>>& grid) {\n\t\tint counter = 0;\n\t\tfor (int i = 0; i < grid.size(); ++i)\n\t\t\tfor (int j = 0; j < grid[i].size(); ++j)\n\t\t\t\tif ('1' == grid[i][j])\n\t\t\t\t{\n\t\t\t\t\t++counter;\n\t\t\t\t\tDFS(grid, i, j);\n\t\t\t\t}\n\t\treturn counter;\n\t}\n};"
		],
		[
			17.0704332711851,
			16.986486728617336,
			15,
			47.5,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n    if (grid.size() == 0) return 0;\n    vector<vector<int>> cnt(grid.size(), vector<int>(grid[0].size(), 0));\n    \n    int max = 0;\n    int dup = 0;\n    map<int, int> mapping;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == '1') {\n                int a = (i == 0) ? 0: cnt[i-1][j]; \n                int b = (j == 0) ? 0: cnt[i][j-1];\n                if (a == 0 && b == 0) {\n                    max++;\n                    cnt[i][j] = max;\n                    mapping[max] = max;\n                } else if (a == 0) { // b != 0\n                    cnt[i][j] = b;\n                } else if (b == 0) { // a != 0\n                    cnt[i][j] = a;\n                } else if (a == b) {\n                    cnt[i][j] = a;\n                } else { // both not zero and not equal\n                    if (mapping[a] != mapping[b]) {\n                        dup++;\n                        if (mapping[a] > mapping[b]) {\n                            remap(mapping, a, mapping[b]);\n                        } else {\n                            remap(mapping, b, mapping[a]);\n                        }\n                    }\n                    cnt[i][j] = mapping[a];\n                }\n            }\n        }\n    }\n    return max - dup;\n}\n\nvoid remap(map<int,int>& mapping, int key, int val) {\n    mapping[mapping[key]] = val; // important\n    mapping[key] = val;\n} };"
		],
		[
			17.46591002623481,
			15.219194096954734,
			12,
			34.3966,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    grid[i][j] = '0';\n                    queue<pair<int, int>> todo;\n                    todo.push({i, j});\n                    while (!todo.empty()) {\n                        pair<int, int> p = todo.front();\n                        todo.pop();\n                        for (int k = 0; k < 4; k++) {\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '1') {\n                                grid[r][c] = '0';\n                                todo.push({r, c});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return islands;\n    }\n};"
		],
		[
			17.556191508388032,
			15.219194096954734,
			11,
			47.6471,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    eraseIslands(grid, i, j);\n                }\n            }\n        }\n        return islands;\n    }\nprivate:\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\n        int m = grid.size(), n = grid[0].size();\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == '0') {\n            return;\n        }\n        grid[i][j] = '0';\n        eraseIslands(grid, i - 1, j);\n        eraseIslands(grid, i + 1, j);\n        eraseIslands(grid, i, j - 1);\n        eraseIslands(grid, i, j + 1);\n    }\n};"
		],
		[
			17.491307118406898,
			15.219194096954734,
			11,
			25.4167,
			"class Solution {\npublic:\n    int maxX, maxY, res = 0;\n    void dfs(vector<vector<char>>& grid, int x, int y) {\n\t    // checking if we are out of bounds\n        if (x < 0 || x == maxX || y < 0 || y == maxY) return;\n        char &currCell = grid[y][x];\n        if (currCell != '1') return;\n        // we mark it as visited\n        currCell = '#';\n        // exploring right, left, down, up\n        dfs(grid, x + 1, y);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x, y - 1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        maxY = grid.size();\n        // exit condition for empty map\n        if (!maxY) return res;\n        maxX = grid[0].size();\n        for (int y = 0; y < maxY; y++) {\n            for (int x = 0; x < maxX; x++) {\n                if (grid[y][x] == '1') {\n                    // oh, we found an island!\n                    res++;\n                    // then we need to mark all the tiles on that island as visited!\n                    dfs(grid, x, y);\n                }\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			17.36516941738023,
			15.219194096954734,
			14,
			28.8372,
			"class Solution {\npublic:\n    int maxX, maxY, res = 0;\n    void dfs(vector<vector<char>>& grid, int x, int y) {\n        char &currCell = grid[y][x];\n        if (currCell != '1') return;\n        // we mark it as visited\n        currCell = '#';\n        // exploring right, left, down, up\n        if (x + 1 < maxX) dfs(grid, x + 1, y);\n        if (x > 0 || x == maxX || y < 0 || y == maxY) dfs(grid, x - 1, y);\n        if (y + 1 < maxY) dfs(grid, x, y + 1);\n        if (y > 0) dfs(grid, x, y - 1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        maxY = grid.size();\n        // exit condition for empty map\n        if (!maxY) return res;\n        maxX = grid[0].size();\n        for (int y = 0; y < maxY; y++) {\n            for (int x = 0; x < maxX; x++) {\n                if (grid[y][x] == '1') {\n                    // oh, we found an island!\n                    res++;\n                    // then we need to mark all the tiles on that island as visited!\n                    dfs(grid, x, y);\n                }\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			17.73848824349856,
			15.219194096954734,
			11,
			49.6111,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int label = 0;\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        \n        for (int i = 0; i < rowNum; ++i) {\n            for (int j = 0; j < colNum; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j, rowNum, colNum);\n                    ++label;\n                }\n            }\n        }\n        \n        return label;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int row, int col, \n                      int& rowNum, int& colNum) {\n        if (row < 0 || col < 0 || row >= rowNum || col >= colNum || grid[row][col] == '0') return;\n        \n        grid[row][col] = '0';\n        dfs(grid, row + 1, col, colNum, rowNum);\n        dfs(grid, row - 1, col, colNum, rowNum);\n        dfs(grid, row, col + 1, colNum, rowNum);\n        dfs(grid, row, col - 1, colNum, rowNum);\n    }\n};"
		],
		[
			16.57657017333483,
			15.219194096954734,
			12,
			48.0278,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int label = 0;\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        \n        for (int i = 0; i < rowNum; ++i) {\n            for (int j = 0; j < colNum; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    ++label;\n                }\n            }\n        }\n\t\t\n        return label;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int row, int col) {\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        if (row < 0 || col < 0 || row >= rowNum || col >= colNum || grid[row][col] == '0') return;\n        \n        grid[row][col] = '0';\n        dfs(grid, row + 1, col);\n        dfs(grid, row - 1, col);\n        dfs(grid, row, col + 1);\n        dfs(grid, row, col - 1);\n    }\n};"
		],
		[
			17.704868590400405,
			15.219194096954734,
			13,
			41.6818,
			"class Solution {\npublic:\n   //make as visited as you traverse by making it \"0\"(change from land to water)\n    void bfs(vector<vector<char>>& grid, int i, int j, int n, int m){\n        grid[i][j] = '0';\n        \n        if(i-1 >= 0 && grid[i-1][j] == '1') //up\n            bfs(grid, i-1, j, n, m);\n        if(i+1 < n && grid[i+1][j] == '1') //down\n            bfs(grid, i+1, j, n, m);\n        if(j+1 < m && grid[i][j+1] == '1') //right\n            bfs(grid, i, j+1, n, m);\n        if(j-1 >= 0 && grid[i][j-1] == '1') //left\n            bfs(grid, i, j-1, n, m);\n    }\n        \n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == '1'){\n                    bfs(grid, i, j , n, m);\n                    count++;\n                }    \n            }\n        }\n        return count;\n    }\n};\n"
		],
		[
			8.488312451469056,
			15.219194096954732,
			12,
			59.375,
			"class Solution {\npublic:\n    void dfs(int i, int j, vector<vector<char>>& grid, int rows, int cols){\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(i - 1, j, grid, rows, cols);\n        dfs(i + 1, j, grid, rows, cols);\n        dfs(i, j - 1, grid, rows, cols);\n        dfs(i, j + 1, grid, rows, cols);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int cnt = 0;\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1'){\n                    dfs(i, j, grid, rows, cols);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.322485165105434,
			15.219194096954734,
			24,
			69.4878,
			"typedef pair<int, int> pii;\n\nclass Solution {\npublic:\n    void makeSet(pii x, map<pii, pair<pii, int>>& m, int& cnt){\n        m.insert(make_pair(x, make_pair(x, 0)));\n        cnt++;\n    }\n    \n    pii findSet(pii x, map<pii, pair<pii, int>>& m){\n        if(m[x].first == x) return x;\n        else{\n            m[x].first = findSet(m[x].first, m);\n            return m[x].first; \n        }\n    }\n    \n    void unionSet(pii x, pii y, map<pii, pair<pii, int>>& m, int& cnt){\n        pii parX = findSet(x, m);\n        pii parY = findSet(y, m);\n        if(parX == parY) return;\n        \n        int rankX = m[parX].second; \n        int rankY = m[parY].second;\n        if(rankX < rankY) m[parX].first = parY;\n        else m[parY].first = parX;\n        \n        if(rankX == rankY) m[parX].second += 1; \n        cnt--; \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int rows = grid.size(), cols = grid[0].size();\n        map<pii, pair<pii, int>> m; // map to parent & rank\n        int cnt = 0; // counter for sets\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1') makeSet(make_pair(i, j), m, cnt);\n            }\n        }\n        int x = 0, y = 0;\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1'){\n                    // explore four directions\n                    x = i - 1;\n                    y = j;\n                    if(x >= 0 && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    x = i + 1;\n                    if(x < rows && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    x = i;\n                    y = j - 1;\n                    if(y >= 0 && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    y = j + 1;\n                    if(y < cols && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			17.404876132669727,
			15.219194096954734,
			14,
			51.3043,
			"class Solution {\npublic:\n    \n    void DepthFirstSearch(vector<vector<char>> &grid, int r, int c){\n        int Rows = grid.size();\n        int Columns = grid[0].size();\n        \n        grid[r][c] = '0';\n        \n        if (r+1 <  Rows    && grid[r+1][c] == '1') DepthFirstSearch(grid, r+1, c); //visit uper\n        if (r-1 >= 0       && grid[r-1][c] == '1') DepthFirstSearch(grid, r-1, c); //visit lower \n        if (c+1 <  Columns && grid[r][c+1] == '1') DepthFirstSearch(grid, r, c+1); //visit right\n        if (c-1 >= 0       && grid[r][c-1] == '1') DepthFirstSearch(grid, r, c-1); //visit left\n        \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int numberOfIslands = 0;\n        int Rows = grid.size();\n        if (Rows == 0) return 0;\n        int Columns = grid[0].size();\n        \n        for (int iI = 0; iI < Rows; iI++){\n            for (int iJ = 0; iJ < Columns; iJ++){\n                if (grid[iI][iJ] == '1'){\n                    numberOfIslands++;\n                    DepthFirstSearch(grid, iI, iJ);\n                }\n            }\n        }\n        \n        return numberOfIslands;\n    }\n};"
		],
		[
			1.0,
			1.0,
			14,
			52.6923,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int numberOfIslands = 0;\n        int Rows = grid.size();\n        if (Rows == 0) return 0;\n        int Columns = grid[0].size(); \n        \n        stack<pair<int, int>> s;\n        \n        for (int iI = 0; iI < Rows; iI++){\n            for(int iJ = 0; iJ < Columns; iJ++){\n                if (grid[iI][iJ] == '1'){\n                    numberOfIslands++;\n                    grid[iI][iJ] = '0';\n                    s.push(pair(iI, iJ));\n                    while(!s.empty()){\n                        pair rc = s.top();\n                        s.pop();\n                        int r = rc.first, c = rc.second;\n                        if(r+1 < Rows    && grid[r+1][c] == '1'){\n                            s.push(pair(r+1,c));\n                            grid[r+1][c] = '0';\n                        }\n                        if(r-1 >= 0      && grid[r-1][c] == '1'){\n                            s.push(pair(r-1,c));\n                            grid[r-1][c] = '0';\n                        }\n                        if(c+1 < Columns && grid[r][c+1] == '1'){\n                            s.push(pair(r,c+1));\n                            grid[r][c+1] = '0';\n                        }\n                        if(c-1 >= 0      && grid[r][c-1] == '1'){\n                            s.push(pair(r,c-1));\n                            grid[r][c-1] = '0';\n                        }\n                    }\n                }\n            }\n        }\n        \n        return numberOfIslands;\n    }\n};"
		],
		[
			18.29725288472175,
			15.219194096954734,
			12,
			38.641,
			"class Solution {\npublic:\n    //dfs + recursive\n    //time: o(row * column)\n    //space: o(row)\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty())\n            return 0;\n        \n        int count_of_islands = 0;\n        for(int row = 0; row < grid.size(); ++row) {\n            for(int col = 0; col < grid[0].size(); ++col) {\n                if(grid[row][col] == '1') {\n                    ++count_of_islands;\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\n                }   \n            }  \n        }\n        return count_of_islands;\n    }\nprivate:\n    //dfs to mark every grid in this island.\n    int dfs(vector<vector<char>>& grid, int row, int col) {\n        grid[row][col] = '2';\n        for(auto d : dir) {\n            int next_row = row + d.first;\n            int next_col = col + d.second;\n            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == '1') {\n                dfs(grid, next_row, next_col);\n            }   \n        }\n        return 0;\n    }\nprivate:\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\n};"
		],
		[
			17.963240361730616,
			15.219194096954734,
			12,
			40.6154,
			"class Solution {\npublic:\n    //bfs + iterative\n    //time: o(row * column)\n    //space: o(column)\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty())\n            return 0;\n        \n        int count_of_islands = 0;\n        for(int row = 0; row < grid.size(); ++row) {\n            for(int col = 0; col < grid[0].size(); ++col) {\n                if(grid[row][col] == '1') {\n                    ++count_of_islands;\n                    std::queue<pair<int, int>> bfs_que;//<row, column>\n                    grid[row][col] = '2';\n                    bfs_que.push(make_pair(row, col));\n                    while(!bfs_que.empty()) {\n                        std::pair<int, int> visited_node = bfs_que.front();\n                        bfs_que.pop();\n                        for(auto d : dir) {\n                            int next_row = visited_node.first + d.first;\n                            int next_col = visited_node.second + d.second;\n                            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == '1') {\n                                grid[next_row][next_col] = '2';\n                                bfs_que.push(make_pair(next_row, next_col));\n                            }\n                            \n                        }\n                    }\n                }   \n            }  \n        }\n        return count_of_islands;\n    }\n\nprivate:\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\n};"
		],
		[
			19.23467203633026,
			15.219198662624617,
			12,
			44.5946,
			"class Solution {\npublic:\n    int nr_row, nr_col;\n    const int TYPE_WATER = 0x7fffffff;\n    int numIslands(vector<vector<char> > &grid) {\n        if (grid.empty() || grid[0].empty()) {\n            return 0;\n        }\n        nr_row = grid.size();\n        nr_col = grid[0].size();\n\n        int type_num = 0;\n        vector<int> type(nr_col + 1, TYPE_WATER); //type[k+1] => grid[x][k] type\n        unordered_map<int, int> table;            //\u5e76\u67e5\u96c6, disjoint set\n        for (int i = 0; i < nr_row; ++i) {\n            for (int j = 0; j < nr_col; ++j) {\n                int near_type = min(type[j], type[j+1]);\n                if (grid[i][j] == '1') {\n                    if (type[j] != TYPE_WATER && type[j+1] != TYPE_WATER) {\n                        int group1 = find_parent(table, type[j]);\n                        int group2 = find_parent(table, type[j+1]);\n                        table[max(group1, group2)] = min(group1, group2);\n                    }\n                    if (near_type == TYPE_WATER) {\n                        type[j+1] = ++type_num;\n                        table[type[j+1]] = type[j+1];\n                    } else {\n                        type[j+1] = near_type;\n                    }\n                } else {\n                    type[j+1] = TYPE_WATER;\n                }\n            }\n        }\n\n        unordered_set<int> s;\n        for (int i = 1; i <= type_num; ++i) {\n            s.insert(find_parent(table, i));\n        }\n        return s.size();\n    }\n\n    int find_parent(unordered_map<int, int> &table, int type) {\n        return table[type] == type ? type :\n                table[type] = find_parent(table, table[type]);\n    }\n};"
		],
		[
			17.96068141855459,
			15.317879321466405,
			19,
			48.7097,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0){\n            return 0;\n        }\n        int m = grid.size();\n        int n = grid[0].size();\n        int ret = 0;\n        stack<pair<int, int>> s;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == '1' && !visited[i][j]){\n                    ret++;\n                    s.push(make_pair(i, j));\n                    while(!s.empty()){\n                        pair<int, int> cur = s.top();\n                        s.pop();\n                        int x = cur.first;\n                        int y = cur.second;\n                        visited[x][y] = true;\n                        if((x+1) < m && grid[x+1][y] == '1' && !visited[x+1][y]){\n                            s.push(make_pair(x+1, y));\n                        }\n                        if((x-1) >=0 && grid[x-1][y] == '1' && !visited[x-1][y]){\n                            s.push(make_pair(x-1, y));\n                        }\n                        if((y+1) < n && grid[x][y+1] == '1' && !visited[x][y+1]){\n                            s.push(make_pair(x, y+1));\n                        }\n                        if((y-1) >= 0 && grid[x][y-1] == '1' && !visited[x][y-1]){\n                            s.push(make_pair(x, y-1));\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};"
		],
		[
			17.452535403499265,
			15.318386844219892,
			19,
			48.7097,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0){\n            return 0;\n        }\n        int m = grid.size();\n        int n = grid[0].size();\n        int ret = 0;\n        queue<pair<int, int>> q;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == '1' && !visited[i][j]){\n                    ret++;\n                    q.push(make_pair(i, j));\n                    while(!q.empty()){\n                        pair<int, int> cur = q.front();\n                        q.pop();\n                        int x = cur.first;\n                        int y = cur.second;\n                        visited[x][y] = true;\n                        if((x+1) < m && grid[x+1][y] == '1' && !visited[x+1][y]){\n                            q.push(make_pair(x+1, y));\n                        }\n                        if((x-1) >=0 && grid[x-1][y] == '1' && !visited[x-1][y]){\n                            q.push(make_pair(x-1, y));\n                        }\n                        if((y+1) < n && grid[x][y+1] == '1' && !visited[x][y+1]){\n                            q.push(make_pair(x, y+1));\n                        }\n                        if((y-1) >= 0 && grid[x][y-1] == '1' && !visited[x][y-1]){\n                            q.push(make_pair(x, y-1));\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};"
		],
		[
			18.120830949930188,
			15.219194096954734,
			10,
			53.6071,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid,int i,int j){\n        if(i<0||j<0||i>=grid.size()||j>=grid[i].size()||grid[i][j]=='0')\n            return;\n        grid[i][j]='0';\n        dfs(grid,i+1,j);\n        dfs(grid,i-1,j);\n           dfs(grid,i,j-1);\n         dfs(grid,i,j+1);\n        return ;\n        }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int x=0;\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                if(grid[i][j]=='1'){\n                    dfs(grid,i,j);\n                    x++;   \n                }\n            }         \n        }\n          return x;  }};"
		],
		[
			17.290091497649605,
			15.219194096954734,
			11,
			44.5,
			"class Solution {\npublic:\n    int count=0;\n    int numIslands(vector<vector<char>>& grid) {\n        int row=grid.size();\n        int col=grid[0].size();\n        for (int i=0; i<row; i++) {\n            for (int j=0; j<col; j++) {\n                if (grid[i][j]=='1') count++, dfs (grid, i, j) ;\n            }\n        }\n        return count;\n    }\n    void dfs (vector<vector<char>> &grid, int i, int j) {\n        if (i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!='1') return;\n        grid[i][j]='0';\n        vector <vector<int>> v={{0,1}, {1,0}, {-1,0}, {0,-1}};\n        for (int x=0; x<4; x++) {\n            dfs (grid, i+v[x][0], j+v[x][1]);\n        }\n    }\n};\n"
		],
		[
			17.586095340941668,
			15.219194096954734,
			12,
			39.4615,
			"class Solution {\npublic:\n    int rowArr[4] = {1, -1, 0, 0};\n    int colArr[4] = {0, 0, 1, -1};\n    \n    bool isValid(vector<vector<char>>& grid, int i, int j){\n        int R = grid.size();\n        int C = grid[0].size();\n        return i>=0 && i<R && j>=0 && j<C && grid[i][j] == '1';\n    }\n    \n    void dfs(vector<vector<char>>& grid, int i, int j){\n        \n        grid[i][j] = '0';\n        for(int k = 0; k<4; k++){\n            int r = i + rowArr[k];\n            int c = j + colArr[k];\n            \n            if(isValid(grid, r, c))\n                dfs(grid, r, c);\n        }\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        \n        int rows = grid.size();\n        int cols = grid[0].size();\n        int cnt = 0;\n      \n        for(int i = 0; i<rows; i++){\n            for(int j = 0; j<cols; j++){\n                if(grid[i][j] == '1'){\n                    dfs(grid, i, j);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};\n"
		],
		[
			18.319211116320275,
			15.219194096954734,
			11,
			59.5385,
			"class Solution {\npublic:\n      int dfs(vector<vector<char>>& grid,int i,int j){\n        if(i<0||j<0||i>grid.size()-1||j>grid[0].size()-1||grid[i][j]=='0')\n            return 0;\n        grid[i][j]='0';\n        dfs(grid,i+1,j);\n        dfs(grid,i-1,j);\n        dfs(grid,i,j+1);\n        dfs(grid,i,j-1);\n          \n        return 1;  \n    } \n\t\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size()==0 )  return 0;\n        int ans=0;\n        for(int i=0;i<grid.size();i++)\n\t\t{\n            for(int j=0;j<grid[0].size();j++)\n\t\t\t{\n                if(grid[i][j]=='1')\n                {  \n                    ans+=dfs(grid,i,j);            \n                }\n            }\n        }\n        return ans;\n    }\n};"
		]
	],
	"CATALAN_NUM": [
		"n^2",
		[
			16.596898230666657,
			4.266807006446484,
			3,
			24.0,
			"class Solution {\npublic:\n    #include<vector>\n    int numTrees(int n) {\n        vector<int> dp(n+1);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i]+=(dp[j]*dp[i-j-1]);\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.50245106567796,
			4.266807006446484,
			10,
			29.9178,
			"/*\n    https://leetcode.com/problems/unique-binary-search-trees/\n    \n    For a current n, each node 'i' till 'n' can become\n    a root, and the elements smaller than 'i' are left \n    subtree nodes and greater than 'i' are part of right subtree.\n    Both left and right subtree nodes then again be arranged amongst themselves\n*/\nclass Solution {\npublic:\n    // using bottom-up approach\n    int numTreesTabular(int n) {\n        if(n <= 1)\n            return 1;\n        \n        vector<int> dp(n + 1, 0);\n        // there is exactly one way to get a BST with 0 or 1 node\n        dp[0] = dp[1] = 1;\n        \n        // Cn = Sum( Ci * C((n-1) - i)) , 0 <= i <= n-1\n        for(int i = 2; i <= n; i++) {\n            for(int j = 0; j <= i-1; j++) {\n                dp[i] += dp[j] * dp[i - 1 - j];\n            }\n        }\n        return dp[n];\n    }\n    \n    // using memoization\n    int numTreesRec(int n, vector<int>& dp) {\n        if(n <= 1)\n            return 1;\n        \n        // for current n, each node 'i' till 'n' can become\n        // a root, and the elements smaller than 'i' are left \n        // subtree and greater than 'i' are part of right subtree\n        // both left and right subtree nodes then again be arranged amongst themselves\n        if(dp[n] == 0) {\n            for(int i = 1; i <= n; i++) \n                dp[n] += numTreesRec(i - 1, dp) * numTreesRec(n - i, dp);\n        }\n        return dp[n];\n    }\n    \n    // driver function for memoization\n    int numTreesRecDriver(int n) {\n        vector<int> dp(n + 1, 0);\n        return numTreesRec(n, dp);\n    }\n    \n    \n    int numTrees(int n) {\n        // return numTreesRecDriver(n);\n        return numTreesTabular(n);\n    }\n};\n"
		],
		[
			16.587460998767593,
			4.266807006446484,
			3,
			27.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int>dp(n+1,0);\n        dp[0]=1;\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=i;j++)\n                dp[i]+=dp[i-j]*dp[j-1];\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.60246653373426,
			4.266807006446484,
			4,
			40.7143,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        // trival cases\n        if (n <= 1) {\n            return n;\n        }\n        // dp: dp[k] = sum_{j=0}^{k-1} (dp[j] * dp[k-j-1]) \n        vector<int> dp(n+1, 0);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int k(2); k <= n; ++k) {\n            dp[k] = 0;\n            for (int j(0); j < k; ++j) {\n                dp[k] += dp[j] * dp[k-j-1];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.49088920956099,
			4.266807006446484,
			3,
			21.1765,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 10, 0);\n        dp[0] = 1; // Null tree is still a tree\n        dp[1] = 1;\n        for (int i{2}; i <= n; i++) {\n            for (int j{}; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};"
		],
		[
			16.61694264238349,
			4.266807006446483,
			3,
			25.65,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1,0);\n        dp[1] = 1;\n        for(int i=2; i<=n;i++){\n            // when n is leaf node or root node, count of such trees is dp[n-1]\n            dp[i]+= 2*dp[i-1];\n\n         // when n is intermediate node we have nodes on both sides of node n \n        // if there are x nodes above node n, no of trees which can be formed above =dp[x]\n        // There will be n-1 - x nodes below node n \n        // no of trees which can be formed  below = dp[n-1-x]\n    \n        // we can select any permutation of the trees above and below\n    //therefore total number of trees with node n as intermediate  =  dp[x] * dp[n-1-x]\n            \n            for(int j=1; j<i-1; j++)\n                dp[i]+= dp[j]*dp[i-1-j];\n         \n        }\n        return dp[n];\n        \n    }\n};\n"
		],
		[
			17.89323994372094,
			4.266807006446483,
			5,
			39.75,
			"class Solution {\npublic:\n\tvector<int> v;\n\tint numTressHelper(int n) {\n\t\tif (v[n] != 0)\n\t\t\treturn v[n];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[n] += numTressHelper(i - 1) * numTressHelper(n - i);\n\t\t}\n\t\treturn v[n];\n\n\t}\n\tint numTrees(int n) {\n\t\tv.resize(n + 1);\n\t\tv[0] = 1;\n\t\tv[1] = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += numTressHelper(i - 1) * numTressHelper(n - i);\n\t\t}\n\t\treturn sum;\n\t}\n};\n"
		],
		[
			15.225480856203466,
			1.0,
			4,
			31.6818,
			"class Solution {\npublic:\n    int numTrees(int n) {\n            \n        if(n<3) return n;\n        \n        int a[n+1],i,j;\n        a[0]=1, a[1]=1;\n        \n        for(i=2;i<=n;i++)\n        {\n            a[i]=0;\n            for(j=0;j<i;j++)\n                a[i] += a[j]*a[i-j-1];\n        }\n        return a[n];\n    }\n};\n"
		],
		[
			16.587971996162597,
			4.266807006446484,
			3,
			27.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int k = 1; k <= i; ++k) {\n                dp[i] += dp[k - 1] * dp[i - k];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			15.454929333326874,
			4.266807006446483,
			4,
			33.3333,
			"class Solution {\npublic:\nint numTrees(int n) {\n    vector<int> trees(n+1, 1);\n    for(int i = 2; i <= n; i++)\n    {\n        int j = 0, k = i-1;\n        for(; j < k; j++, k--)\n            trees[i] += (trees[j] * trees[k] * 2);\n        if(j == k)\n            trees[i] += (trees[j] * trees[k]);\n    }\n    return trees[n];\n}\n};"
		],
		[
			16.58468233032001,
			4.266807006446484,
			6,
			38.0,
			"class Solution {\npublic:\n\tint numTrees(int n) {\n\t\tif(n==0) return 1;\n\t\tif(n==1) return 1;\n\t\tif(n==2) return 2;\n\t\tvector<int> dp(n+1,0);\n\t\tdp[0]=1;\n\t\tdp[1]=1;\n\t\tdp[2]=2;\n\t\tfor(int i=3;i<n+1;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tdp[i]+=dp[j-1]*dp[i-j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n];\n\t}\n};"
		],
		[
			13.91972380513352,
			1.0,
			4,
			42.3182,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[n+1];\n        dp[0]=1,dp[1]=1;\n        for(int i=2;i<=n;i++){\n            int total=0;\n            for(int j=0;j<i/2;j++)\n                total+=dp[j]*dp[i-j-1]*2;\n            dp[i]=total+(i%2==0?0:dp[i/2]*dp[i/2]);\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			53.57160666331231,
			4.266807006446484,
			7,
			30.8125,
			"class Solution {\npublic:\n\nint numTrees(int n) {\n    if (n <= 0) return 0;\n    \n    int result = 0;\n    vector<int> array(n + 1, 0);\n    \n    array[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        int cur = array[0];\n        \n        for (int j = 0; j < i - 1; j++) {\n            int next = array[j + 1];\n            \n            for (int k = 0; k <= j + 1; k++) {\n                if (k != j)\n                    array[k] += cur;\n            }\n            cur = next;\n        }\n    }\n    for (int r = 0; r < n + 1; r++)\n        result += array[r];\n    return result;\n}\n};"
		],
		[
			53.2704430645742,
			4.266807006446484,
			7,
			30.8125,
			"class Solution {\npublic:\n\nint numTrees(int n) {\n    if (n <= 0) return 0;\n    \n    int result = 0;\n    vector<int> array(n + 1, 0);\n    \n    array[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        int cur = array[0];\n        \n        for (int j = 0; j < i - 1; j++) {\n            int next = array[j + 1];\n            \n            for (int k = 0; k <= j + 1; k++) {\n                if (k != j)\n                    array[k] += cur;\n            }\n            cur = next;\n        }\n    }\n    for (int r = 0; r < n + 1; r++)\n        result += array[r];\n    return result;\n}\n};"
		],
		[
			16.826312233465373,
			1.0,
			3,
			28.5,
			"class Solution {\npublic:\nint numTrees(int n) {\nlong long int dp[n+1];\nmemset(dp,0,sizeof(dp));\ndp[0]=1;\nfor(int i=1;i<=2*n;i++){\nfor(int j=min(i,n);j>0;j--){\ndp[j]=dp[j-1]+dp[j];\n}\n}\nreturn dp[n]/(n+1);\n}\n};"
		],
		[
			63.31635937770158,
			16.311521014234586,
			5,
			38.0769,
			"class Solution {\npublic:\nint func(int l,int r,vector<vector<int>>&dp){\n        if(r<l){return 1;}\n        if(dp[l][r]!=-1)return dp[l][r];\n        int temp=0;\n        for(int i=l;i<=r;i++){\n            temp+=func(l,i-1,dp)*func(i+1,r,dp);\n        }\n        return dp[l][r]=temp;\n    }\n    int numTrees(int n) {\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\n        return func(1,n,dp);\n    }\n};"
		],
		[
			17.93647193636917,
			1.0,
			6,
			40.5909,
			"class Solution {\npublic:\nint func(int n,vector<int>&dp){\n        if(n==1 || n==0)return dp[n]=1;\n        if(dp[n]!=-1)return dp[n];\n        int temp=0;\n        for(int i=1;i<=n;i++){\n            temp+=func(i-1,dp)*func(n-i,dp);\n        }\n        return dp[n]=temp;\n    }\n    int numTrees(int n) {\n        vector<int>dp(n+1,-1);\n        return func(n,dp);\n    }\n};"
		],
		[
			15.216281232547278,
			1.0,
			3,
			27.0,
			"class Solution {\npublic:\nint numTrees(int n) {\n\n    int arr[n+1];\n    arr[0]=1;\n    arr[1]=1;\n    \n    for(int i=2;i<=n;i++)\n    {\n        arr[i]=0;\n        for(int j=0;j<i;j++)\n        {\n            arr[i]+=arr[j]*arr[i-j-1];\n        }\n    }\n    return arr[n];\n}\n};"
		],
		[
			15.480694231900548,
			1.0,
			5,
			35.0769,
			"class Solution {\nprivate:\n    int history[10000] = {};\npublic:\n    int numTrees(int n) {\n        if(n<=1) return 1;\n        else{\n            int count = 0;\n            for(int i =1;i<=n ;i++){\n                int left_count = history[i-1];\n                if(!left_count) {\n                    left_count = numTrees(i-1);\n                    history[i-1] = left_count;\n                }\n                int right_count = history[n-i];\n                if(!right_count){\n                    right_count = numTrees(n-i);\n                    history[n-i] = right_count;\n                }\n                count += left_count * right_count;\n            }\n            return count;\n        }\n    }\n};"
		],
		[
			16.606940251111055,
			4.266807006446484,
			4,
			35.1,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if (n < 0) return 1;\n        \n        vector<int> bst(n+1, 0);\n        int i = 0, j = 0;\n        bst[0] = 1;\n        \n        for (i = 1; i <= n; ++i)\n            for (j = 1; j <= i; ++j)\n                bst[i] += (bst[j-1] * bst[i-j]);\n                \n        return bst[n];\n    }\n};"
		],
		[
			16.591353704553132,
			4.8115803230595455,
			3,
			24.0833,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> f;\n        f.push_back(1);\n        for (int i = 1; i <= n; ++ i){\n            f.push_back(0);\n            for (int j = 1; j <= i; ++ j)\n                f[i] += f[j - 1] * f[i - j];\n        }\n        return f[n];\n    }\n};"
		],
		[
			25.238592700965253,
			5.371591767636878,
			3,
			25.5,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        map<int, int> Mymap;\n\t\tMymap[0] = 1;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t    int cont = 0;\n\t\t\tfor (int k = 0; k < i; k++)\n\t\t\tcont+= Mymap[k] * Mymap[i - 1 - k];\n\t\t\tMymap[i] = cont;\n\t\t}\n\t\treturn Mymap[n];\n    }\n};"
		],
		[
			5.0209787817831995,
			1.0,
			2,
			16.6667,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        unsigned long  c=1;\n        for(int i = 1;i < n;  ) c = 2*(++i*2 -1)*c/(i + 1);\n        return c;\n    }\n};\n"
		],
		[
			14.99701051371882,
			1.0,
			5,
			34.7083,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n < 2) return 1;\n        if(n == 2) return 2;\n        int DP[n + 1];\n        DP[0] = 1;\n        DP[1] = 1;\n        int sub_res = 0;\n        for(int i = 2; i <= n; i++){\n            sub_res = 0;\n            for(int j = 1; j <= i; j++){\n                sub_res += DP[i - j] * DP[j - 1];\n            } \n            DP[i] = sub_res;\n        }\n        return DP[n];\n    }\n};"
		],
		[
			4.2262224601028615,
			1.0,
			2,
			22.2632,
			"//as for n number of trees possible= ((2n)C(n))/(n+1)\n //(2n)C(n) is equal to ((2n)*(2n-1)*...n terms) / (n*(n-1)*...*1)\n\n class Solution {\n public:\n     int numTrees(int n) {\n         double ans=1,i=2*n;\n         for(int j=1;j<=n;j++,i--){\n             ans*=(i/j);\n              }\n         return ans/(n+1);\n     }\n };"
		],
		[
			16.58211744934605,
			4.266807006446484,
			3,
			23.5385,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i]+=dp[j]*dp[i-j-1];  //catalan number\n            }\n        }\n        return dp[n];\n    }\n};"
		],
		[
			16.214592582769352,
			1.0,
			6,
			18.375,
			"class Solution {\npublic:\n    vector<int> sols = {1, 1, 2};\n    int nextSol(int n) {\n        // accumulator variable for the result\n        int res = 0;\n        // and I proceed to consider all the possible occurrences, leveraging pre-computed solutions\n        for (int i = 0; i < n; i++) {\n            res += sols[i] * sols[n - i - 1];\n        }\n        return res;\n    }\n    void expandSols(int n) {\n        // helper to expand sol - notice that I start with lower numbers, going up to n\n        while (sols.size() <= n) {\n            sols.push_back(nextSol(sols.size()));\n        }\n    }\n    int numTrees(int n) {\n        // checks if I have already the results in sol, otherwise it expands it\n        return n < sols.size() ? sols[n] : (expandSols(n), sols[n]);\n    }\n};"
		],
		[
			15.193090077145385,
			1.0,
			3,
			25.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[++n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i < n; i++) {\n            dp[i] = 0;\n            for (int j = 0; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n};"
		],
		[
			16.615334279395483,
			4.266807006446483,
			3,
			19.2273,
			"class Solution {\npublic:\nint numTrees(int n) {\n        // let C[i] be the number of unique binary search trees with 1 to i\n        vector<int> C(n+1,1);\n        \n        for (int i = 2; i <= n; ++i) {\n            C[i] = 0;\n            for (int j = 1; j <= i; ++j) {\n                C[i] += C[j-1] * C[i-j];\n            }\n        }\n        return C[n];\n    }\n};"
		],
		[
			15.48004394832137,
			4.266807006446484,
			4,
			36.0938,
			"class Solution {\npublic:\nint numTrees(int n) \n{\n\tvector<int> t(n + 1, 0);\n\tt[0] = t[1] = 1;\n\tint i, j;\n\tfor (i = 2; i <= n; ++i)\n\t{\n\t\tfor (j = 1; j <= i / 2; ++j)\n\t\t\tt[i] += t[j - 1] * t[i - j];\n\t\tt[i] *= 2;\n\t\tif (i % 2)\n\t\t\tt[i] += t[i / 2] * t[i / 2];//Plus the middle 'root' trees.\n\t}\n\treturn t[n];\n}\n};"
		],
		[
			15.8154629203599,
			4.864390269036466,
			3,
			23.5385,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int sum;\n        vector<int> temp;\n        temp.push_back( 1 );\n        for( int i = 1; i <= n; i++ )\n        {\n            sum = 0;\n            for( int j = 1; j <= i; j++ )\n                sum += temp[ j - 1 ] * temp[ i - j ];\n            \n            temp.push_back( sum );\n        }\n        return temp[ n ];\n    }\n};"
		],
		[
			26.560203241427562,
			5.371591767636878,
			4,
			28.8,
			"class Solution {\npublic:\nint numTrees(int n)\n    {\n    \tif (n <= 0)\n    \t\treturn 0;\n    \n    \tmap<int, int> dic;\n    \tdic[0] = 1;\n    \tfor (int i = 1; i <= n; i++)\n    \t{\n    \t\tfor (int j = 1; j <= i; ++j)\n    \t\t{\n    \t\t\tdic[i] += dic[j - 1] * dic[i - j];\n    \t\t}\n    \t}\n    \treturn dic[n];\n    }\n};"
		],
		[
			15.986863161444013,
			4.789620858732048,
			4,
			27.6923,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n == 0)\n        {\n            return 0;\n        }\n        vector<int> ret(1,1);\n        for(int i = 1; i <= n; i++)\n        {\n            int result = 0;\n            for(int j = 0; j < i; j++)\n            {\n                result += ret[j] * ret[i-1 - j];\n            }\n            ret.push_back(result);\n        }\n        return ret[n];\n    }\n};"
		],
		[
			15.211262659983063,
			1.0,
			3,
			27.0,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        \n        int catalan[n+1];\n        \n        catalan[0] = 1;\n        catalan[1] = 1;\n        \n        for(int i=2;i<=n;i++){\n            catalan[i] = 0;\n            for(int j=0;j<i;j++){\n                catalan[i]+= catalan[j]*catalan[i-j-1];\n            }\n        }\n        \n        return catalan[n];\n    }\n};\n"
		],
		[
			15.07355514764985,
			4.266807006446484,
			3,
			24.7059,
			"class Solution\n{\npublic:\n    \tint numTrees( int n )\n    \t{\n\t\t        int * a =new int[n + 1];\n\t\t        a[0] = 0;\n\t\t        a[1] = 1;\n\t\t        a[2] = 2;\n\t\t        a[3] = 5;\n\t\t\n\t\tfor( int i = 4; i <= n; ++i )\n\t\t{\n\t\t\t    int current = 2 * a[i - 1] + 2 * a[i - 2];\n\n\t    \t\tfor( int j = 3; j < i - 1; ++j )\n\t\t    \t{\n\t\t\t        \tcurrent += ( a[j - 1] * a[i - j] );\n\t\t\t    }\n\t\t\t    a[i] = current;\n\t\t}\n\t        \tint out = a[n];\n\t        \tdelete [] a;\n\t\t        return out;\n    \t}\n};"
		],
		[
			16.598700135710203,
			4.266807006446484,
			5,
			31.6667,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n==0)\n            return 1;\n        if(n==1)\n            return 1;\n        vector<int> dp(n+1, 1);\n        int ans=0;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i]=0;\n            for(int j=0;j<i;j++)\n            {\n                dp[i]+=(dp[j]*dp[i-j-1]);\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			4.267527688242771,
			1.0,
			2,
			21.4138,
			"class Solution {\npublic:\n\tint numTrees(int n) {\n\t\tdouble ans=1, i=2*n;\n\t\t//using formula directly i.e for value=n, number of trees possible= ((2n)C(n))/(n+1)\n\t\t//calculating numerator (2n)C(n) that is equal to ((2n)*(2n-1)*...n terms) / (n*(n-1)*...*1)\n\n\t\tfor(int j=1; j<=n; i--,j++){ // i goes from 2n to n terms and j goes from 1 to n\n\t\t\tans*= i/j;\n\t\t}\n\n\t\treturn ans/(n+1);\n\t}\n};"
		],
		[
			16.784349363931906,
			4.266807006446484,
			3,
			28.5909,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        \n        vector<int> dp(n+1,0);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            \n            \n            for(int j=1;j<=i;j++){\n                dp[i]=dp[i]+(dp[j-1]*dp[i-j]);\n            }\n            \n        }\n        \n        return dp[n];\n    }\n};\n"
		],
		[
			57.301893561890985,
			1.0,
			7,
			38.25,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[n][n];\n        memset(dp, 0, sizeof(dp));\n        for(int i=0;i<n;i++) {\n            dp[i][i] = 1;\n        }\n        for(int l=2;l<=n;l++) {\n            int i = 0;\n            for(int j=l-1;j<n;j++) {\n                for(int k=0;k<=j;k++) {\n                    dp[i][j] += ((k-1 >= i ? dp[i][k-1] : 1) * (k+1 < j ? dp[k+1][j] : 1));\n                }\n                i++;\n            }\n        }\n        return dp[0][n-1];\n    }\n};"
		],
		[
			16.532855365903885,
			4.266807006446484,
			3,
			24.7273,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for(int i = 2; i <= n; i++) {\n            for(int j = 0; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		]
	],
	"REVERSE_INTEGER": [
		"1",
		[
			1.0,
			1.0,
			4,
			12.1875,
			"class Solution {\npublic:\n    int reverse(int xx) {\n      bool neg=false;\n        long long int x=xx;\n        if(x<0)\n        {\n            neg=true;\n            x*=-1;\n        }\n        int ans;\n        string s=to_string(x);\n        std::reverse(s.begin(),s.end());\n        try{\n            ans=stoi(s); \n        }\n        catch(out_of_range& e)\n        {\n            return 0;\n        }\n        if(neg)\n            ans*=-1;\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			15.0,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long result = 0L;\n        while (x) {\n            result = result * 10 + (x % 10);\n            x /= 10;\n        }\n        \n        return (result >= (long) INT_MAX || result <= (long) INT_MIN) ? 0 : result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			14.2222,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int tut = x;\n        if(x >= INT_MAX || x <= INT_MIN){\n            return 0;\n        }\n\t\t//makes positive\n        if(x<0){\n            tut = -tut;\n        }\n        string s = to_string(tut);\n        ::reverse(s.begin(),s.end());\n\t\t//add '-' later\n        if(x<0){\n            s.insert(s.begin(),'-');\n        }\n        try{\n            x = stoi(s);\n        }\n        catch(const std::out_of_range& e){\n            return 0;\n        }\n        return x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.75,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rem = 0;\n        while(x)\n            {   if(rem > INT_MAX/10 || rem< INT_MIN/10)\n                    return 0;\n                rem = rem*10 + x%10 ;\n                x =x/10;\n            }   \n    return rem;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			16.875,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x) {\n            if (rev > INT_MAX / 10) return 0; // overflow check\n            if (rev < INT_MIN / 10) return 0;\n            rev = rev * 10 + x % 10;\n            x /= 10;\n        }\n        return rev ;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long result = 0;\n\n        while(x != 0) {\n            result *= 10;\n            result += x % 10;\n            x /= 10;\n        }\n\n        if (result <= INT_MIN || result >= INT_MAX) {\n            result = 0;\n        }\n        \n        return (int)result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			22.9091,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long long int rem, ans = 0; \n        while(x > 0 || x < 0){\n            rem = x % 10;\n            ans = (ans * 10) + rem;\n            x /= 10;\n        }\n        if(ans > INT_MAX || ans < INT_MIN){\n            return 0;\n        }\n        else{\n            return ans;\n        }  \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.4091,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint rev = 0;\n\twhile (x != 0) {\n\t\tif (rev > INT_MAX / 10 || rev < INT_MIN / 10)\n\t\t\treturn 0;\n\n\t\tint pop = x % 10;\n\t\trev = rev * 10 + pop;\n\t\tx /= 10;\n\t}\n\treturn rev;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			20.0962,
			"class Solution {\npublic:\n    int reverse(int x) \n    {\n        int flag = 0; //marks negativity \n        \n        if(x < 0)\n            flag = 1;\n        \n        int num = abs(x);\n        long int newNum = 0; //long to avoid integer overflow\n        \n        while(num > 0)\n        {\n            int rem = num % 10;\n            \n            if(newNum*10 > INT_MAX) //to avoid signed integer overflow\n                return 0;\n            \n            newNum = newNum*10 + rem; //Multiply by 10 to increment place value\n            num = num/10;\n        }\n        \n        if(flag == 0)\n            return newNum;\n        \n        else\n            return newNum*(-1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			22.6667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        int ori = x;\n\n        bool zeroFlag = true;\n\n        while(ori!=0)\n        {\n            if (ori % 10 == 0 && zeroFlag)\n            {\n                ori = ori / 10;\n                continue;\n            }\n\n            if (rev > INT_MAX / 10 || rev < INT_MIN / 10)\n                return 0;\n\n            rev = rev * 10 + (ori % 10);\n            ori = ori / 10;\n            zeroFlag = false;\n        }\n\n        return rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			23.5435,
			"class Solution {\npublic:\n    int reverse(int num) {\n        if(num == -2147483648) return 0;\n        \n        int rev = 0;\n\t    bool isNeg = false;\n\t   \n\t    if(num < 0) {\n\t        isNeg = true;\n\t        num = num * -1;\n\t    }\n\t    \n        while(num >= 10) {\n            rev = rev * 10 + num % 10;\n            num = num / 10;\n        }\n        \n\t\t// Checking for overflow when adding the last digit\n        // 2147483647 / 10 = 214748364\n        if(rev > 214748364) return 0;\n            \n        if(rev >= 214748364 && num > 7) return 0;\n        \n        rev = rev * 10 + num % 10;\n        \n        if(isNeg) {\n            rev = rev * -1;\n        }\n            \n        return  rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long ans=0;\n        while(x!=0)\n        {\n            ans=ans*10+x%10;\n            x=x/10;\n            if(ans>INT_MAX||ans<INT_MIN) return 0;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.2167,
			"class Solution {\npublic:\n    int reverse(long x)\n    {   \n        long temp = x;\n        \n        // if x is negative, we make it positive and reverse it and then add sign at returning\n        if(x < 0)\n            temp = -x;\n        \n        long rev = 0, unit = 0;\n        while(temp != 0)\n        {\n            unit = temp % 10;\n            rev=  rev * 10 + unit;\n            // if reversed number is greater than 32 bits ie INT_MAX \n            if( rev >= INT_MAX )\n                return 0;\n            temp/=10;\n        }\n        // if number is negative, then we add negative sign\n        if(x < 0)\n            return -rev;\n        else\n            return rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			36.8824,
			"class Solution {\npublic:\n    int reverse(int x) {\n        stringstream ss;\n        long long int ans;\n        ss << x;\n        string str;\n        ss >> str;\n        if(str[0]=='-') for(int i =1 ; i<=str.size()/2 ; i++)swap(str[i], str[str.size() -i]);\n        else for(int i =0 ; i<str.size()/2 ; i++)swap(str[i], str[str.size()-1 -i]);\n        ss.str(\"\");\n        ss.clear();\n        ss << str;\n        ss >> ans;\n        if((abs(ans) >> 31) != 0)return 0;\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			16.5,
			"class Solution {\npublic:\nint reverse(int x) {\n\tstring a = to_string(x);\n\tstring res = \"\";\n\tif(a.find(\"-\")!=string::npos){\n\t\tres += \"-\";\n\t}\n\tfor(int i=a.length()-1; i>=0; i--){\n\t\tres += a.substr(i, 1);\n\t}\n\tif(stoll(res) > 2147483647 || stoll(res) < -2147483648){\n\t\treturn 0;\n\t}\n\treturn stoi(res);\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			13.4545,
			"class Solution {\npublic:\n    int reverse(int x) {\n        string str;\n        stack<char> integers;\n        if (x < 0)\n            str += \"-\";\n        \n        string input = to_string(abs(x));\n        for (char const &c: input) \n            integers.push(c);\n        \n        while (!integers.empty()) {\n            str += integers.top();\n            integers.pop();\n        }\n        \n        if (abs(stol(str)) > INT_MAX)\n            return 0;\n        \n        return stoi(str);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			15.6,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int r{0};\n        \n        while (x / 10) {\n            r *= 10;\n            r += x % 10;\n            x /= 10;\n        }\n        \n        if (r / (INT_MAX / 10 + 1)) {\n            return 0;\n        }\n            \n        return r * 10 + x;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.6923,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int y=0;\n        \n        while(x){\n            if(INT_MAX/10 < y){\n                return 0;\n            }\n            if(INT_MIN/10 > y){\n                return 0;\n            }\n            \n            //As it was given in question that the input is 32 bit integer, if the input number is positive and while reversing it is greater than +2147483647(INT_MAX) then the output should be 0. But if the input number is negetive and while reversing it is less than -2147483648(INT_MIN) then also the output should be 0.\n            \n            y = y*10 + x%10;\n            x = x/10;\n        }\n        return y;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			33.6154,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int res = 0;\n        while(x) {\n            bool checkPosNotOverflow = x > 0 && res <= INT_MAX / 10 && res * 10 <= INT_MAX - x % 10;\n            bool checkNegNotOverflow = x < 0 && res >= INT_MIN / 10 && res * 10 >= INT_MIN - x % 10;\n            if (checkPosNotOverflow || checkNegNotOverflow) res = res * 10 + x % 10;\n            else return 0;\n            x /= 10;\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			15.4286,
			"class Solution {\npublic:\n    int reverse(int x) {\n        bool isNegative{}; // False by default\n        int newInt{};\n        \n        if (x < 0)\n        {\n            isNegative = true;\n            if (x == numeric_limits<int>::min()) return 0; // If it's the lowest number, return 0\n            x *= -1; // This will overflow if we are given the smallest potential number.\n\t\t\t// But by the time we reach here we've already returned 0. Otherwise this multiplication won't\n\t\t\t// give us any issues. We want to turn all negative numbers positive to not deal with negatives\n\t\t\t// in multiplication below.\n        }\n        \n\t\t// Reverse an integer\n        while (x)\n        {\n            // Check integer overflow\n            if (newInt > INT_MAX / 10 || newInt < INT_MIN / 10) return 0;\n            newInt = newInt * 10 + x % 10;\n            x /= 10;\n        }\n        // Restore negative if the number was originally negative\n        return isNegative ? -1 * newInt : newInt;\n    }\n};\n"
		],
		[
			3.0186650060438813,
			1.0,
			6,
			27.8182,
			"class Solution {\npublic:\n\tint reverse(int x) {\n\t\tint sum = 0;\n\t\tint y = x;\n\t\twhile(y!=0){\n\t\t\tif(x>0){\n\t\t\t\tif((INT_MAX-y%10)/10<sum){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(x < 0){\n\t\t\t\tif((INT_MIN-y%10)/10>sum){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = sum*10+y%10;\n\t\t\ty /= 10;\n\t\t}\n\t\treturn sum;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			6,
			14.9697,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (!x)\n            return 0;\n        string rev = \"\";\n        bool negative = x < 0 ? true : false;\n        long y = x;\n        try\n        {\n            y = abs(y);\n            // Reverse the digits\n            while (y)\n            {\n                rev += to_string(y % 10);\n                y /= 10;\n            }\n            // Add a minus sign if the original number was negative\n            return negative ? stoi(rev.insert(0, 1, '-')) : stoi(rev);\n        }\n        // For cases of overflow\n        catch(...)\n        {\n            return 0;\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			19.4366,
			"/**\n    https://leetcode.com/problems/reverse-integer/\n    \n    TC: O(1), 32 bit numbers have a limited num of digits\n    SC: O(1)\n**/\nclass Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        // instead of checking separately for negative and \n        // positive number, we can combine the checks by making the num +ve.\n        // in case the the x is neg, then the max limit \n        // is INT_MAX + 1, but since we are limited to 32bits we can\n        // use the unsigned var to store just +1 of INT_MAX\n        unsigned int max_limit = x < 0 ? (unsigned int)INT_MAX + 1 : INT_MAX;\n        bool neg = x < 0;\n        // take absolute value for calc\n        x = abs(x);\n        \n        // simple reversal with overflow checks\n        while(x) {\n            // overflow due to multiplcation\n            if(rev > max_limit / 10)\n                return 0;\n            rev *= 10;\n            // overflow due to addition\n            if(rev > max_limit - x % 10)\n                return 0;\n            rev = rev + x % 10;\n            x /= 10;\n        }\n        return rev * (neg ? -1 : 1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			24.2105,
			"class Solution {\npublic:\nint reverse(int x) {\n        int res=0,flag=-1;\n        if(x==INT_MIN) \n            return 0;\n\t// flag for marking -ve numbers.\t\n        if(x<0){\n            flag=1;\n            x=abs(x);\n        }\n        while(x>0){\t\t\n\t\t//condition check for overflow.\t\t\n            if(res>INT_MAX/10) \n                return 0;\n            res=res*10+x%10;\n            x/=10;\n            \n        }\n        if(flag==1)\n            res=-1*res;\n        return res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			3,
			18.6207,
			"// 1. Use C++ INT_MAX/INT_MIN (defined similar to boundaries of the problem)\n// 2. Multiply 'ret' by 10 to add another zero each iteration\n// 3. Strip the last digit from 'x' with the modulus operator\n// 4. Add the stripped off last digit to 'ret'\n// 5. If 'x' divided by 10 == 0, then we have removed all digits from 'x'.\nclass Solution {\npublic:\n    int reverse(int x) {\n        long long ret = 0;\n        while (x != 0) {\n\n            // Iteration    |    1      |    2      |    3\n            // ret = 0      | 0 + 3 = 3 |  30+2=32  | 320+1=321\n            //  x  = 123    | 123/10=12 |  12/10=1  | 1/10=0 ==>>> exit loop\n\n            ret = (ret*10) + (x%10);\n            x /= 10;\n\n            if (abs(ret) > INT_MAX) {\n                return 0;\n            }\n        }\n        return ret;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			28.3333,
			"class Solution {\npublic:\n    int reverse(int x) {\n      \n        int z = 0;\n      \n        while(x){\n        \n            if(z>INT_MAX/10 || z==INT_MAX/10 && x%10>7)\n                return 0;\n            if(z<INT_MIN/10 || z==INT_MIN/10&&x%10<-8)\n                return 0;\n         \n            z = z *10 +x%10;x = x/10;\n        }\n        \n        return z;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			20.5714,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int reverse = 0;\n        \n        while(x != 0){\n            // Check overflow\n            if(reverse > (INT_MAX/10 - (x%10)/10) || reverse < (INT_MIN/10-(x%10)/10)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\t// Calculate reversed integer\n            reverse = reverse*10 + x%10;\n            x /= 10;\n        }\n        \n        return reverse;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			10,
			25.6442,
			"class Solution {\npublic:\n    int reverse(int x) {\n        //check if the first part overflows\n        if (x > INT_MAX || x < INT_MIN) return 0;\n        \n        int reverse = 0;\n        \n        while(x != 0) {     \n            //these conditions check if reverse will be larger than INT_MAX or smaller than INT_MIN by a factor of 10.\n            //the 7 and -8 are represent the last digit of INT_MAX and INT_MIN.\n            //Their condition explains that as long as the remainder is from 0 to 7, or -8 to 0 inclusive,\n            //the x value can be from 0 to INT_MAX, or INT_MIN to 0 range.\n            if ((reverse > INT_MAX/10 || reverse < INT_MIN/10) && ((x > 0 && (x % 10 <= 7)) || x < 0 && (x % 10 >= -8))) return 0;\n            \n            //change reverse value\n            reverse = reverse * 10 + x % 10;\n            \n            //to get next values, divide x by ten\n            x /= 10;\n        }\n        \n        return reverse;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\nint reverse(int x) {\n        long long int ans=0;\n        while(x!=0)\n        {\n            ans=(ans*10) +(x%10);\n            x/=10;\n            if(ans> INT_MAX)\n                return 0;\n            if(ans<INT_MIN)\n                return 0;\n        }\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			7,
			25.1471,
			"class Solution {\npublic:\n    int reverse(int x) {\n        string s = to_string(x);\n        int base = 1;\n        int i = s[0] == '-' ? 1 : 0;\n        int res = 0;\n        while(i < s.size()){\n            if(base == 1000000000 && (s[i] - '0' > 2 || INT_MAX - (s[i] - '0') * base < res)) return 0;\n            res += (s[i] - '0') * base;\n            base *= 10;\n            i++;\n        }\n        return s[0] == '-' ? -res : res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			22.1,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint result = 0;\n\twhile (x != 0){\n\t\tif (INT_MAX / 10 < result||INT_MIN/10>result){\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tresult = result * 10 + x % 10;\n\t\t}\n\t\tx /= 10;\n\t}\n\treturn result;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			22.1,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long returnInt = 0;\n        while (x)\n        {\n            returnInt = returnInt*10+x%10;\n            x/=10;\n        }\n        if (returnInt>0)\n            return returnInt > INT_MAX ? 0 : returnInt;\n        else return returnInt < INT_MIN ? 0 : returnInt;\n    }\n};"
		],
		[
			1.0,
			1.0,
			3,
			19.5,
			"class Solution {      \npublic:        \n      int reverse(int x) {     \n        int res =0,tmp = res;   \n        for(;x;tmp = res,res = x%10 + res*10,x = x/10);     \n        return tmp!=res/10 ?0:res;    \n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.9615,
			"class Solution {\npublic:\nint reverse(int x) {\n    int ans = 0, copy = abs(x);\n\n    while (copy > 0) {\n        if (INT32_MAX / 10 < ans) return 0;  // check overflow\n        ans = ans * 10 + copy % 10;\n        copy /= 10;\n    }\n\n    return x < 0 ? -ans : ans;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			23.5238,
			"class Solution {\npublic:\nint reverse(int x) {\n        int p=x>0?x:-x;     \n             // p is the abs value\n        long int result=0;\n             // in case of overflow, we choose long int\n        while(p!=0){\n            result=result*10+p%10;\n            p/=10;\n        }\n             //reverse the abs value\n        result=(x>0)?result:-result;\n             //check if x>0\n        if(result>INT_MAX||result<INT_MIN)\n            return 0;\n             //check overflow\n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			29.2917,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (x == 0) return x;\n        int sign = 1;\n        long long int sum = 0;\n        if (x < 0) \n            x = -x, sign = -1;\n        \n        while (x > 0)\n        {\n            sum = sum * 10 + (x % 10);\n            x /= 10;\n            \n            if (sum * sign > INT_MAX || sum * sign < INT_MIN)\n                return 0;\n        }\n        \n        return (int)sum * sign;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			28.5,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (x == 0) return x;\n        int sum = 0, low = 0, sign = 1;\n        if (x < 0) \n            x = -x, sign = -1;\n        \n        while (x > 0)\n        {\n            low = x % 10;\n            if ((INT_MAX - low) / 10 < sum)\n                return 0;\n            sum = sum * 10 + low;\n            x /= 10;\n\n        }\n        \n        return sign * sum;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7857,
			"class Solution {\npublic:\nint reverse(int x) {\n        if (x == 0) {\n            return 0;\n        } else {\n            int res = 0;\n            int _x = abs(x);\n            int flag = _x / x;\n            while (_x > 0) {\n                int curr = _x % 10;\n                //in case overflow\n                if (res > (INT_MAX - curr) / 10) {\n                   return 0;\n                } else  {\n                    res  = res * 10 + curr;\n                    _x = _x / 10;\n                }\n            }\n            return flag * res;\n        }\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			25.5,
			"class Solution\n{\npublic:\n    int reverse(int x)\n    {\n        if(x == 0)\n            return 0;\n            \n        long result = 0;  \n        \n        while(x % 10 == 0)\n            x /= 10;\n        while(x)\n        {\n            result = result*10 + x % 10;\n            \n            if(result >= INT_MAX || result<= INT_MIN)\n                return 0;\n            x /= 10;\n        }\n        \n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			16.0312,
			"class Solution {\n public:\n    int reverse(int x) {\n        long result = 0;           // Final result\n        long op = x < 0 ? -1 : 1;  // Get the operator\n\n        long tmp = abs((long)x);  // Avoid too many type conversions and work with positive number\n        while (tmp) {             // When tmp is zero, stops\n            result += tmp % 10;   // Get the last number\n            result *= 10;\n            tmp /= 10;\n        }\n        result /= 10;  // Remove the last zero\n\n        return result > (long)INT_MAX ? 0 : result * op;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			17.3333,
			"#include <climits>\n\nclass Solution{\npublic:\n    int reverse(int x){\n        long s = 0;         \n        while (x != 0) {\n            s =s*10 + x%10;\n            x = x/10;\n        }\n        if (s > INT_MAX || s < INT_MIN) return 0;\n        return s;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			19.8333,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int tag = x < 0 ? -1 : 1;\n        unsigned long temp = 0;\n\n        x *= tag;\n        for( ; x; x /= 10 )\n        {\n            temp = temp * 10 + x % 10;\n            if( temp > INT_MAX )\n                return 0;\n        }\n        return temp * tag;\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			22.6935,
			"class Solution {\npublic:\nint reverse(int x) {\n    if(x==INT_MIN)//solve this situation, we can use x=abs(x)\n        return 0;\n\tint isPositive=1;\n\tif(x<0)\n\t{\n\t    x=abs(x);\n\t    isPositive=-1;\n\t}\n\tint result=0;\n\tint int_maxp=INT_MAX/10;\n\twhile(x!=0)\n\t{\n\t\tif (result>int_maxp)//don't need to check \"result==int_maxp&&q>int_maxq\"\uff0cbecause this can't happen (x is type int)\n\t\t{\n\t\t\tresult=0;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tresult=10*result+x%10;\n\t\tx=x/10;\n\t}\n\tresult=isPositive*result;\n\treturn result;\n};\n"
		],
		[
			1.0,
			1.0,
			10,
			31.0,
			"class Solution {\npublic:\nint reverse(int x) {\n    int minimum = INT_MIN, maximum = INT_MAX;\n    int res = 0, sign;\n    sign = (x<0)?-1:1;\n    if (x == minimum)\n        return 0;\n    x *= sign;  // here check x==minimum first\n    while (x) {\n        int tmp = sign*res;\n        if (tmp>maximum/10 || tmp<minimum/10 || (tmp==maximum/10 && x%10>maximum%10) || (tmp==minimum/10 && x%10<minimum%10))\n            return 0;\n        res = 10*res + x%10;\n        x /= 10;\n    }\n    return res*sign;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			20.0,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int y=0;\n        while(x){\n            if(y>INT_MAX/10 || y<INT_MIN/10){\n                return 0;\n            }else{\n                y=y*10 +x%10;\n                x=x/10;\n            }\n        }\n        return y;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			17.25,
			"class Solution {\npublic:\nint reverse(int x) {\n    long result = 0;\n    while(x != 0)\n    {\n        result = result*10 + x % 10;\n        x /= 10;\n    }\n    return (result > INT_MAX || result < INT_MIN)? 0 : result;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			33.125,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint ch[40] = {};\n\tint i = 0;\n\tint flag = 1;\n\tif (x < 0)\n\t{\n\t\tflag = -1;\n\t\tx = abs(x);\n\t\t\n\t}\n\n\twhile (x>0)\n\t{\n\t\tch[i++] = x % 10;\n\t\tx=x / 10;\n\t}\n\tint length = i;\n\n\n\tint reverse = 0;\n\tfor (size_t i = 0; i < length; i++)\n\t{\n\t\tif (ch[i]!=0)\n\t\t{\n\t\t\treverse += ch[i]*pow(10, length - i-1);\n\t\t\tif (reverse < 0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reverse*flag;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			25.375,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int a = r(x);\n        if(r(a) != x && x % 10 != 0) return 0;\n        else return a;\n    }\n    \n    int r(int x)\n    {\n        int r = 0;\n        while(x != 0)\n        {\n            r *= 10;\n            r += x % 10;\n            x /= 10;\n        }\n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			23.1818,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int x_cp = abs(x);\n        long result = 0;\n        while(x_cp) {\n            result = result*10+ x_cp%10;\n            x_cp /= 10;\n        }\n        if(result > 2147483647 || result < -2147483648) return 0;\n        return x >0 ? result : -result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.6667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long num = abs((long)x);\n        long new_num = 0;\n        while(num) {\n            new_num = new_num*10 + num%10;\n            num /= 10;\n        }\n        \n        if (new_num > INT_MAX) {\n            return 0;\n        }\n        return (x<0 ? -1*new_num : new_num);\n    }\n};"
		],
		[
			1.0,
			1.0,
			10,
			28.7692,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int result = 0;\n        while (x != 0)\n        {\n            int a = x % 10;\n            if (a > 0 && (result > INT_MAX/10 || (result == INT_MAX/10 && a > 7))) return 0;\n            if (a < 0 && (result < INT_MIN/10 || (result == INT_MIN/10 && a < -8))) return 0;\n\n            result = result*10 + a;\n            x /= 10;\n        }\n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.1667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        \n         int t = abs(x);\n         int sum =0;\n         int restraint  = pow(2,31)-1;\n         int res;\n        \n         while(t>0){\n            \n            if(sum<=restraint/10){\n                sum = sum*10+t%10;\n                t = t/10;\n            }else{\n                return 0;\n            }\n            \n        }\n        res = x>=0?sum:-sum;   \n        return res; \n       \n         \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			13,
			45.5,
			"class Solution {\npublic:\n    int reverse(int x) {\n        bool negativeFlag = false;\n        \n        if (x<0){\n            negativeFlag = true;\n            \n            if ((x <= INT_MAX) && (x > INT_MIN)) x = -x;\n            else return 0;\n        \n        }\n        \n        int rev_num = 0, prev_rev_num = 0;\n        \n        while (x != 0){\n            int curr_digit = x % 10;\n            \n            if (rev_num > INT_MAX/10 || (rev_num == INT_MAX / 10 && curr_digit > 7)) return 0;\n            if (rev_num < INT_MIN/10 || (rev_num == INT_MIN / 10 && curr_digit < -8)) return 0;\n            \n            rev_num = (rev_num * 10) + curr_digit;\n                                 \n            \n            if ((rev_num - curr_digit)/10 != prev_rev_num)\n                return 0;\n            \n            prev_rev_num = rev_num;\n            x = x / 10;\n        }\n        \n        return (negativeFlag == true) ? -rev_num : rev_num;\n\t\t}\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			27.7083,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if(x==0)return 0;\n        long long int n=x;\n        if(n<0)n=-n;\n        long long int ans=0;\n        while(n>0){\n            ans=ans*10+n%10;\n            n=n/10;\n            if(ans>pow(2,31)-1)return 0;\n        }\n        if(x<0)return -ans;\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.5455,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int newX = 0;\n        \n        while (x != 0) {\n            if (newX > (INT_MAX-abs(x%10))/10 || newX < (INT_MIN+abs(x%10))/10) \n                return 0;\n            newX = newX*10 + x%10;\n            x /= 10;\n        }\n        \n        return newX;\n    }   \n};\n"
		]
	],
	"REVERSE_LL": [
		"n",
		[
			5.541980586942202,
			4.9012741893949,
			2,
			14.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL, *node = head; \n        while (node) {\n            ListNode* temp = node->next; \n            node->next = prev; \n            prev = node; \n            node = temp; \n        }\n        return prev; \n    }\n};\n"
		],
		[
			5.582843706368771,
			4.9012741893949,
			2,
			12.8571,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        //create two pointers pre, next\n        ListNode* pre=NULL;\n        ListNode* next=NULL;\n        //Run the loop till we reach the end\n        while(head){\n            next=head->next;\n            head->next=pre;\n            pre=head;\n            head=next;\n        }\n        //return the last pointer\n        return pre;\n    }\n};\n"
		],
		[
			5.540513837178394,
			4.9012741893949,
			4,
			28.9474,
			"\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr)return head;\n        ListNode* first;\n        ListNode* p;\n        vector<ListNode*>tab;\n        p=head;\n        while(p->next!=nullptr){\n            tab.push_back(p);\n            p=p->next;\n        }    \n        first=p;\n        int n=tab.size();\n        for(int i=n-1;i>=0;i--){\n            p->next=tab[i];\n            p=tab[i];\n        }\n        p->next=nullptr;\n        return first;\n        \n    }\n};\n"
		],
		[
			5.556561047596531,
			4.9012741893949,
			2,
			27.5,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* d = NULL;\n        while(head != NULL){\n            ListNode* next = head->next;\n            head->next = d;\n            d = head;\n            head = next;\n        }\n        \n        return d;\n    }\n};\n"
		],
		[
			5.560538463602518,
			4.9012741893949,
			2,
			18.7,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *current=head;\n        ListNode *next=NULL,*prev=NULL;\n        while(current!=NULL)\n        {\n            next=current->next;\n            current->next=prev;\n            prev=current;\n            current=next;\n        }\n        head=prev;\n        return head;\n    }\n};\n"
		],
		[
			5.550041908932439,
			4.9012741893949,
			2,
			12.2143,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n\t/*initialize current, next, and previous pointers*/\n        ListNode* curr=head;\n        ListNode* next=NULL;\n        ListNode* prev=NULL;\n        while(curr!=NULL)\n        {\n\t\t/*store next*/\n            next=curr->next;\n\t\t\t\n\t\t\t/*reverse current node's pointer*/\n            curr->next=prev;\n\t\t\t\n\t\t\t/*move pointers one position ahead*/\n            prev=curr;\n            curr=next;\n        }\n        head=prev;\n\t\t/*return the reversed linked list*/\n        return head;\n    }\n};\n"
		],
		[
			5.534769914001696,
			4.9012741893949,
			2,
			18.15,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *current, *previous, *next;\n        current = head;\n        previous = NULL;\n        \n        while(current){\n            next = current->next;\n            current->next = previous;\n            previous = current;\n            current = next;\n        }\n        \n        head = previous;\n        return head;\n    }\n};\n"
		],
		[
			5.541486217089054,
			4.9012741893949,
			2,
			28.2353,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode * current = head;\n        ListNode * previous = nullptr;\n        ListNode * next = nullptr;\n        \n        while(current!=NULL){\n            next=current->next;\n            current->next=previous;\n            previous=current;\n            current=next;\n        }\n        return previous;\n    }\n};\n"
		],
		[
			5.659083058711524,
			4.9012741893949,
			2,
			12.65,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head)\n{\n\t ListNode* prev{nullptr};\n\t for( ; head; head = exchange(head->next, exchange(prev, head)));\t \n\t return prev;\n}\n};"
		],
		[
			5.555012376923241,
			4.901274189394899,
			2,
			14.0,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\nListNode* reverseList(ListNode* head) {\n        ListNode *prevNode = NULL;\n        \n        while(head != NULL){\n            ListNode *tempNode  = head->next;\n            head->next = prevNode;\n            prevNode = head;\n            head = tempNode;\n        }\n    return prevNode;\n    }\n};"
		],
		[
			5.544674861982233,
			4.9012741893949,
			4,
			15.5833,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n\n    ListNode* helper(ListNode* prevN,ListNode* nextN){\n        ListNode* cur = nextN->next;\n        nextN->next = prevN;\n        if(cur) return helper (nextN, cur);\n        return nextN;\n    }\n    ListNode* reverseList(ListNode* head) {\n        if(head) return helper(NULL, head);\n        return head;\n    }\n};"
		],
		[
			5.561585653412237,
			4.9012741893949,
			2,
			21.2632,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n      ListNode* q = NULL, *r = NULL; // we requre three pointer p,q,r\n\tListNode* p = head; \n\twhile (p != NULL)\n\t{/*\n\t sliding pointer */\n\t\tr = q; // r  sud come upon q\n\t\tq = p;// q sud come upon p\n\t\tp = p->next;// p sud move to next node \n\t\tq->next = r;// q next sud points on \n\t}\n\treturn q; // once we came out of while loop // 1st pointer sud point on q \n        \n    }\n};\n"
		],
		[
			5.541008134155046,
			4.9012741893949,
			4,
			36.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head)\n    {\n        if(head==NULL || head->next==NULL)\n        {\n            return head;\n        }\n        ListNode* headprev=head;\n        head=head->next;\n        headprev->next=NULL;\n        ListNode* headnew;\n        while(head!=NULL)\n        {\n            headnew=head;\n            head=head->next;\n            headnew->next=headprev;\n            headprev=headnew;\n        }\n        return headnew;\n    }\n};\n"
		],
		[
			5.58207855890668,
			4.9012741893949,
			2,
			16.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* main = head;\n        ListNode* prev = NULL;\n        ListNode* next = NULL;\n        while(main!= NULL)\n        {\n            next = main->next;\n            main->next = prev;\n            prev = main;\n            main = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.520428844322775,
			4.9012741893949,
			3,
			17.6,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n  ListNode* helper(ListNode* head, ListNode* prev) {\n        if (!head) return prev;\n        ListNode* next = head->next;\n        head->next = prev;\n        return helper(next, head);\n      \n        \n    }\n    \n    ListNode* reverseList(ListNode* head) {       \n        return helper (head, NULL);\n        \n    }\n};"
		],
		[
			5.531796019079737,
			4.901274189394899,
			3,
			16.5926,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* dfs(ListNode* head, ListNode* prev) {\n\t\tif (head == nullptr)\n\t\t\treturn prev; // search for the last node of the list\n\t\t\t\n        ListNode* root = dfs(head->next, head);  // get last node of the list\n        head->next = prev; // change current node next pointer to prev node\n        \n        return root; // return last node of the original list (will be first now)\n    }\n    \n    ListNode* reverseList(ListNode* head) {\n       return dfs(head, nullptr);\n    }\n};\n"
		],
		[
			5.557842547079225,
			4.9012741893949,
			3,
			18.15,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(!head)\n        {\n            return head;\n        }\n        ListNode* curr = head;\n        ListNode* prev = NULL;\n        ListNode* next;\n        \n        while(curr)\n        {\n            next = curr -> next;\n            curr -> next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.515382731794856,
			4.9012741893949,
			2,
			17.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n\t//consider prev,curr,next as three boxes beneath 1 2 3 4 5 linked list\n\t//To reverse the address , first copy what current node is pointing and then assign to its prev node\n\t//curr stores address of box in list whose link must be reversed.\n\t//next stores the next node address pointed to by node whose address in curr\n\t//prev stores the add of last before node visited\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* next = NULL;\n        while(curr!=NULL){\n            next = curr->next;//copying node add pointed by add in curr\n            curr->next = prev;//copying curr node next to prev node\n            prev = curr;// the next prev node will be curr node\n            curr = next;//next curr node is next node\n        }\n        return prev;//prev stores last address of last box in the process\n    }\n};\n"
		],
		[
			5.524789735721206,
			4.9012741893949,
			3,
			19.6364,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr)\n            return head;\n        ListNode *curr=head;\n        ListNode *prev=nullptr;\n        ListNode *nxt=nullptr;\n         while(curr!=nullptr)\n        {\n            nxt=curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=nxt;\n        }\n        return prev;\n   }\n};\n"
		],
		[
			5.534359037487449,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n     ListNode* reverseList(ListNode* head) {\n         if(head == nullptr || head->next == nullptr)\n             return head;\n         ListNode* last = reverseList(head->next);\n         head->next->next = head;\n         head->next = nullptr;\n         return last;\n     }\n};\n\n"
		],
		[
			5.518947508966637,
			4.9012741893949,
			3,
			15.7368,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n    ListNode* reverseList(ListNode* head) {\n        queue <ListNode*> list_stack;\n        auto pointer = head;\n        ListNode* res = nullptr;\n        while (pointer)\n        {\n            list_stack.push(pointer);\n            pointer = pointer -> next;\n        }\n        \n        while (!list_stack.empty())\n        {\n            auto current = res;\n            res = list_stack.front();\n            res -> next = current;\n            list_stack.pop();\n        }\n        \n\n        \n        return res;\n    }\n};"
		],
		[
			5.526938731055732,
			4.9012741893949,
			2,
			14.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\nListNode* reverseList(ListNode* head) {\nListNode* nt;\nListNode* prev = NULL;\n\n    ListNode* curr = head;\n    \n    while(curr!=NULL){\n        nt = curr->next;\n        curr->next = prev;\n        \n        prev = curr;\n        curr = nt;\n        \n    }\n    \n    return prev;\n}\n};"
		],
		[
			5.578171115029668,
			4.9012741893949,
			3,
			19.8,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr) \n        {\n            return head;\n        }\n        \n        ListNode* p1 = head;\n        ListNode* p2 = nullptr;\n        \n        while(p1!=nullptr)\n        {\n            p1 = p1->next;\n            head->next = p2;\n            p2 = head;\n            head = p1;\n        }\n        \n        return p2;\n    }\n};\n"
		],
		[
			5.56166267871467,
			4.9012741893949,
			3,
			16.7619,
			"// Recursive Using Extra Memory(Queue)\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        queue<int> tmp;\n        helper(head, tmp);\n        return head;\n    }\n    \n    void helper(ListNode* cur, queue<int> &tmp) {\n        if (cur == NULL) {\n            return;\n        }\n        tmp.push(cur->val);\n        helper(cur->next, tmp);\n        cur->val = tmp.front();\n        tmp.pop();\n    }\n};"
		],
		[
			5.5428201368969505,
			4.9012741893949,
			2,
			15.0,
			"// Iterative In-Place \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* newHead = NULL;\n        while (head) {\n            ListNode *next = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n};"
		],
		[
			5.545523057688134,
			4.9012741893949,
			2,
			18.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        \n\t\t// BASE CASE\n        // if the linked list is empty or has only one node, we are done!\n        if (head == nullptr or head -> next == nullptr) {\n            return head;\n        }\n        \n\t\t// INDUCTION\n        // 1 -> 2 -> 3 -> nullptr\n        // use Recursive leap of faith to reverse the rest of the list\n        ListNode * reverse = reverseList(head -> next);\n        \n        // we got:\n        \n        //    nullptr\n        //      ^\n        //      |\n        // 1 -> 2 <- 3\n        // reverse pointer is actually pointing to 3\n        \n\t\t// HYPOTHESIS\n        // Now that we have our reversed list EXCLUDING the first node\n        // we want 2's next to point to 1\n        // therefore, we can set the next of (next of 1 (which is 2)) to 1, itself\n        ListNode * secondLast = head -> next;\n        secondLast -> next = head;  // as head is the last node in the reversed list(as it was first in our original list) and put nullptr in its next as the next step\n        head -> next = nullptr;\n        return reverse;\n    }\n};\n"
		],
		[
			5.568329712091426,
			4.901274189394899,
			3,
			17.7333,
			"// Recursive In-Place \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        return helper(head, NULL);\n    }\n    \n    ListNode* helper(ListNode* cur, ListNode* newHead) {\n        if (cur == NULL) {\n            return newHead;\n        }\n        ListNode* next = cur->next; // Save next\n        cur->next = newHead;\n        return helper(next, cur);\n    }\n};"
		],
		[
			5.554765085892848,
			4.9012741893949,
			2,
			11.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL;\n        ListNode* current = head;\n        ListNode* next = NULL;\n        \n        while (current) {\n            \n            // Reverse node \n            next = current->next;\n            current->next = prev;\n            \n            // For next iteration\n            prev = current;\n            current = next;\n        }\n        \n        // Outside of while loop current is NULL that's why we are out of while but prev has the last node \n        // which is now the first node\n        return prev;\n        \n    }\n};\n"
		],
		[
			5.537638299419775,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n          if(head==NULL || head->next==NULL)\n              return head;\n         ListNode* p= reverseList(head->next);\n         head->next->next=head;\n         head->next=NULL;\n         return p;   \n    }\n};"
		],
		[
			5.555044080835704,
			4.9012741893949,
			2,
			14.85,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *nextNode, *prevNode = NULL;\n        while (head) {\n            nextNode = head->next;\n            head->next = prevNode;\n            prevNode = head;\n            head = nextNode;\n        }\n        return prevNode;\n    }\n};"
		],
		[
			5.518176491704252,
			4.9012741893949,
			2,
			19.3208,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode * current = head;\n        ListNode * previous = nullptr;\n        ListNode * next = nullptr;\n        \n        // 1 -> 2 -> 3 -> nullptr\n        while (current != nullptr) {\n            // store the next of current and change its value so that it points to previous\n            next = current -> next;\n            // previous(nullptr) <- 1  2 -> 3 -> nullptr\n            current -> next = previous;\n            \n            // Settings for the next iteration\n            \n            // the current will be the previous of next of current\n            previous = current;\n            // move current to its next stored in the first step\n            current = next;\n        }\n        // we are doing this iteration for all the elements in the loop\n        \n        // In the end, our current will point to nullptr(past the list)\n        // and our previous will point to the last node, which for us\n        // is the first node of the reversed list\n        \n        // nullptr <- 1 <- 2 <- 3 \n        \n        return previous;\n    }\n};\n"
		],
		[
			5.568024437523534,
			4.9012741893949,
			2,
			14.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev=NULL;\n        ListNode* curr=head;\n        ListNode* nxt;\n        \n        while(curr!=NULL)\n        {\n            nxt=curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=nxt;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.541773055529368,
			4.9012741893949,
			4,
			30.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if (head == NULL || head->next == NULL){\n            return head;\n        }\n        ListNode *start = head;\n        ListNode *end = start->next;\n        start ->next = NULL;\n        start = end;\n        end = end ->next;\n\t\t\n        while (end != NULL){\n            start->next = head;\n            head = start;\n            start = end;\n            end = end->next;\n        }\n        start->next = head;\n        head = start;\n        return head;\n    }\n};\n"
		],
		[
			5.552213325238729,
			4.9012741893949,
			4,
			23.25,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL || head->next==NULL) return head;\n        //Take two nodes one to point and other to traverse with\n\t\tListNode* prev = NULL;\n        ListNode* curr = head;\n        while(curr->next!=NULL){\n\t\t    //Make a temp node to store the current node\n            ListNode* temp = curr;\n\t\t\t//Move current to the next node\n            curr = curr->next;\n\t\t\t//Reverse the arrow of temp (which was curr) to previous node\n            temp->next = prev;\n\t\t\t// Move prev one step forward\n            prev = temp;\n        }\n\t\t//At last reverse the arrow of last node to prev\n        curr->next = prev;\n\t\t//Return current as head\n        return curr;\n    }\n};\n"
		],
		[
			5.578144333518622,
			4.9012741893949,
			4,
			21.8182,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head ==nullptr || head->next == nullptr)\n            return head;\n        \n        ListNode* rest = head->next;\n        ListNode* reversed = head;\n        reversed->next = nullptr;\n       \n        \n        while(rest)\n        {\n            ListNode* tmp = rest;\n            rest = rest->next;\n            tmp->next = reversed;\n            reversed = tmp;\n        }\n    \n        return reversed;\n    }\n};\n"
		],
		[
			5.590933565217982,
			4.9012741893949,
			2,
			27.7647,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur = head, *prev = NULL, *next;\n        while(cur!=NULL) {\n            next = cur->next;\n            cur->next = prev;\n            prev = cur;\n            cur = next;\n        }\n        head = prev;\n        return head;\n    }\n};\n"
		],
		[
			5.5353254989828296,
			4.9012741893949,
			3,
			29.75,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* util(ListNode* prev, ListNode* cur, ListNode* next) {\n        if(cur==NULL)\n            return prev;\n        next = cur->next;\n        cur->next = prev;\n        prev = cur;\n        cur = next;\n        return util(prev,cur,next);\n    }\n    ListNode* reverseList(ListNode* head) {\n        auto o = util(NULL,head,NULL);\n        return o;\n    }\n};\n"
		],
		[
			5.511988283710715,
			4.9012741893949,
			2,
			13.1818,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head)\n{\n\tif(!head or !head->next) return head;\n\tauto root = reverseList(head->next);\n\thead->next->next = head;\n\thead->next = nullptr;\n\treturn root;\n}\n};"
		],
		[
			5.540039417761261,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head) {\n\tListNode* prev = nullptr;\n\tListNode* cur = head;\n\twhile (cur) {\n\t\tListNode* next = cur->next;\n\t\tcur->next = prev;\n\t\tprev = cur;\n\t\tcur = next;\n\t}\n\treturn prev;\n}\n};"
		],
		[
			5.534808545377994,
			4.9012741893949,
			2,
			16.2,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head,ListNode* pre = NULL) {\n        if(head == nullptr){\n            return pre;\n        }\n        ListNode* next = head->next;\n        head->next = pre;\n        return reverseList(next,head);\n    }\n};\n"
		],
		[
			5.543016575759078,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        while(head){\n            ListNode* next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.6238644324224465,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        while(current){\n            ListNode* next = current->next;\n            current->next = prev;\n            prev = current;\n            current = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.550766764890758,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* prev = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return prev;\n    }\n};\n"
		],
		[
			5.576888695888699,
			4.9012741893949,
			3,
			33.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL)\n            return head;\n        ListNode* p=NULL;\n        ListNode* q=head;\n        ListNode* r=q->next;\n        while(q!=NULL){\n            r=q->next;\n            q->next=p;\n            p=q;\n            q=r;\n        }\n        head=p;\n        return head;\n    }\n};\n"
		],
		[
			5.549121664854881,
			4.9012741893949,
			2,
			19.3721,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n            \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*q; //\n        \n        while(cur!=NULL){\n            q=cur->next; // storing next pointer to modifiy it leater\n            cur->next=prev;  // Reversing the pointer to the prev\n            prev=cur;  // make the prev equal to the last node we added\n            cur=q; // we get the value back from q that we stored at the first of the loop\n        }\n        return prev; /// return the ans\n    }\n    \n};\n      \n"
		],
		[
			5.5312571511596325,
			4.9012741893949,
			2,
			15.5,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL;\n\t\tListNode *cur = head;\n\t\twhile (cur != NULL){\n\t\t\tListNode *next = cur->next;\n\t\t\tcur->next = prev;\n\t\t\tprev = cur;\n\t\t\tcur = next;\n\t\t}\n\t\treturn prev;\n    }\n};"
		],
		[
			5.515608175732883,
			4.9012741893949,
			3,
			18.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head == NULL)\n            return head;\n        ListNode* prevNode = NULL;\n        ListNode* currNode = head;\n        while(currNode) {\n            ListNode* nextNode = currNode->next;\n            currNode->next = prevNode;\n            prevNode = currNode;\n            currNode = nextNode;\n        }\n        return prevNode;\n    }\n};\n"
		],
		[
			5.590119991003216,
			4.9012741893949,
			2,
			24.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = NULL, *curr = head, *next = head;\n        while(curr!=NULL)\n        {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.519043906134297,
			4.9012741893949,
			2,
			24.8889,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*temp;\n        while(cur){\n            temp=cur->next;\n            cur->next=prev;\n            prev=cur;\n            cur=temp;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.669538521176404,
			4.9012741893949,
			2,
			14.4,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*q;\n        \n        while(cur!=NULL){\n            q=cur->next; // storing next pointer\n            cur->next=prev;  // Reversing the pointer\n            prev=cur; \n            cur=q;\n        }\n        return prev;\n    }\n    \n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.2879,
			"class Solution {\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseL(ListNode* cur,ListNode** newhead) {    // using ** so that change remain permanent(similar to call by reference)\n        if(cur->next==NULL){       // base case and also for \"[1]\" case\n             *(newhead)=cur;       // new head\n            return cur;\n        }\n        else{\n        ListNode* n = reverseL(cur->next,newhead);\n        n->next=cur;\n        return cur;\n        }\n    }\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL)          // for [] case\n            return head;\n        ListNode* temp =head;\n        ListNode* t = reverseL(head,&temp);\n        t->next=NULL;       // head = tail\n        return temp;            // returning the new head\n    }\n};\n"
		],
		[
			5.547052847979819,
			4.901274189394899,
			2,
			13.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* newHead = nullptr;\n        while (head) {\n            auto next = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n};\n"
		]
	]
}