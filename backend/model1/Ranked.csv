Label,Time,Space,Cyclomatic,Halstead,Composite Metric,Code,Index,Model_Rank,rank_weightedSum_sumNorm_inverse,rank_weightedSum_maxNorm_inverse,rank_weightedProduct_sumNorm_inverse,rank_weightedProduct_maxNorm_inverse
MAX_PATH_SUM_BT,9.06334748187414,6.257146557337213,6,2.833333333333333,-151.0652716957537,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",10,6.0,1,1,1,1
MAX_PATH_SUM_BT,9.082063520517591,6.257192564944179,6,4.230769230769232,-107.80378983266104,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",9,7.0,2,2,2,2
MAX_PATH_SUM_BT,9.156755951302305,6.2571791828700905,6,3.4615384615384617,-89.72189942623018,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",14,9.0,3,3,3,3
MAX_PATH_SUM_BT,9.164726148898405,6.257171876073802,6,3.4545454545454546,-92.4052246439226,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",16,8.0,4,4,4,4
MAX_PATH_SUM_BT,9.195464319987217,6.257165498633182,11,3.2352941176470584,-85.64687321999145,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",19,10.0,5,5,5,5
MAX_PATH_SUM_BT,9.212762633378023,6.257196156359804,6,2.833333333333333,-54.97207770288471,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",6,13.0,6,6,6,6
MAX_PATH_SUM_BT,9.235269114469526,6.2572013784811364,6,2.833333333333333,-42.26217632170875,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",5,16.0,7,7,7,7
MAX_PATH_SUM_BT,9.256639728599401,6.257276842209758,6,4.0,25.12765145119824,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        answer =  - sys.maxsize - 1\n        def dfs(node):\n            if not node:\n                return 0\n            left_sub_tree = dfs(node.left)\n            right_sub_tree = dfs(node.right)\n            answer = max(answer , left_sub_tree + right_sub_tree + node.val)\n            return max(0 , node.val + max(left_sub_tree , right_sub_tree))\n        dfs(root)\n        return answer\n\n\n    return maxPathSum(makeTree(0,l))\n",2,23.0,8,8,8,8
MAX_PATH_SUM_BT,9.259923922808177,6.2568851987325145,6,4.181818181818182,-280.915895426292,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",18,1.0,9,9,9,9
MAX_PATH_SUM_BT,9.275933260051113,6.257258595876031,6,4.181818181818182,18.193718000021256,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",36,22.0,10,10,10,10
MAX_PATH_SUM_BT,9.202258057612195,6.311333206000482,6,3.333333333333333,42419.26166102228,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",3,37.0,11,11,11,11
MAX_PATH_SUM_BT,9.29502942376682,6.257238670485481,6,2.833333333333333,9.866799118325922,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",24,21.0,12,12,12,12
MAX_PATH_SUM_BT,9.222704588472352,6.311642538707305,6,3.333333333333333,42669.80151734853,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",21,38.0,13,13,13,13
MAX_PATH_SUM_BT,9.307298222191967,6.2571669252990745,6,3.4545454545454546,-41.732737463490906,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",34,17.0,14,14,14,14
MAX_PATH_SUM_BT,9.316034780268383,6.257212626593933,7,3.3,-2.5303806236051987,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",12,19.0,15,15,15,15
MAX_PATH_SUM_BT,9.34738447753784,6.257136937391684,8,2.1818181818181817,-49.92300465507051,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",20,14.0,16,16,16,16
MAX_PATH_SUM_BT,9.359113378007736,6.256982793130067,6,2.833333333333333,-166.38299239533492,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",23,3.0,17,17,17,17
MAX_PATH_SUM_BT,9.359432594799202,6.257343002559294,6,3.4545454545454546,116.37494340366844,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float(""-inf"")\n\n        def postorder(root):\n            if not root:  return 0\n\n            left_val, right_val = max(0, postorder(root.left)), max(0, postorder(root.right))\n            ans = max(ans, (root.val + left_val + right_val))\n            return max((root.val + left_val), (root.val + right_val))\n\n        postorder(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",1,30.0,18,18,18,18
MAX_PATH_SUM_BT,9.36378333589442,6.257203074752438,7,4.038461538461538,8.246446784599303,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",11,20.0,19,19,19,19
MAX_PATH_SUM_BT,9.368310022004316,6.256989746970456,8,5.4375,-157.40749398064708,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",22,4.0,20,20,20,20
MAX_PATH_SUM_BT,9.33889348346457,6.283940857486535,8,4.25,20978.334303136442,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",7,35.0,21,21,21,21
MAX_PATH_SUM_BT,9.379303528417582,6.257098850737611,6,2.833333333333333,-67.59318433060413,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",33,12.0,22,22,22,22
MAX_PATH_SUM_BT,9.398064363318838,6.257334004916799,8,5.4375,124.0979607399907,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",4,32.0,23,23,23,23
MAX_PATH_SUM_BT,9.425078863551738,6.257068668695718,6,3.4615384615384617,-73.75877664042248,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",32,11.0,24,24,24,24
MAX_PATH_SUM_BT,9.482878024589779,6.257075895458825,6,3.4615384615384617,-45.97073944308363,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",26,15.0,25,25,25,25
MAX_PATH_SUM_BT,9.49534863625485,6.25693278167778,6,3.4615384615384617,-153.4919130085656,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",8,5.0,26,26,26,26
MAX_PATH_SUM_BT,9.500101493724204,6.2571960653557275,6,3.4615384615384617,54.91050783042698,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",17,25.0,27,27,27,27
MAX_PATH_SUM_BT,9.505506576642068,6.256899287174237,7,4.038461538461538,-175.8860691429486,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",29,2.0,28,28,28,28
MAX_PATH_SUM_BT,9.533709971874476,6.257232395461107,6,4.230769230769232,96.27739415666885,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",27,28.0,29,29,29,29
MAX_PATH_SUM_BT,9.4981702172337,6.2843636386909525,8,4.25,21371.0159231486,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",25,36.0,30,30,30,30
MAX_PATH_SUM_BT,9.570795943598217,6.2572026391633235,11,3.2352941176470584,87.12075984835606,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",37,27.0,31,31,31,31
MAX_PATH_SUM_BT,9.571591676117317,6.257366470962711,6,2.833333333333333,215.97472106086562,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",15,34.0,32,32,32,32
MAX_PATH_SUM_BT,9.573824004206307,6.257230247074928,8,2.1818181818181817,109.94183979141079,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",38,29.0,33,33,33,33
MAX_PATH_SUM_BT,9.586276149701641,6.25704065414837,6,3.4615384615384617,-34.055933190407636,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",35,18.0,34,34,34,34
MAX_PATH_SUM_BT,9.593335348642217,6.257191207492743,6,2.833333333333333,86.77597986817067,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",28,26.0,35,35,35,35
MAX_PATH_SUM_BT,9.606314669219449,6.257127847653695,7,3.3,42.02783747687117,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",30,24.0,36,36,36,36
MAX_PATH_SUM_BT,9.645372595847704,6.2572429209169105,6,2.769230769230769,147.26528925715598,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",13,33.0,37,37,37,37
MAX_PATH_SUM_BT,9.735395254222494,6.2571618533400475,6,2.769230769230769,118.1045412605158,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",31,31.0,38,38,38,38
