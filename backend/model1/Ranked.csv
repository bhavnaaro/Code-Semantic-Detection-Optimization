Label,Time,Space,Cyclomatic,Halstead,Composite Metric,Code,Scaled_Time,Scaled_Space,Scaled_Cyclomatic,Scaled_Halstead,Index,Model_Rank,rank_weightedSum_sumNorm_inverse,rank_weightedSum_maxNorm_inverse,rank_weightedProduct_sumNorm_inverse,rank_weightedProduct_maxNorm_inverse
MAX_PATH_SUM_BT,9.34738447753784,6.257136937391684,8,2.1818181818181817,-52.01512864831722,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.06275238670747871,-0.4364776598432264,2.0,-1.0732186732186737,20,14.0,1,1,1,1
MAX_PATH_SUM_BT,9.573824004206307,6.257230247074928,8,2.1818181818181817,86.18720058768587,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",0.8037482217116501,0.2956701762024578,2.0,-1.0732186732186737,38,28.0,2,2,2,2
MAX_PATH_SUM_BT,9.06334748187414,6.257146557337213,6,2.833333333333333,-148.51548588901875,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",-1.1496572799352445,-0.3609954370222924,0.0,-0.5238329238329238,10,4.0,3,3,3,3
MAX_PATH_SUM_BT,9.212762633378023,6.257196156359804,6,2.833333333333333,-66.71620974587103,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.577900565946395,0.028179788917547882,0.0,-0.5238329238329238,6,10.0,4,4,4,4
MAX_PATH_SUM_BT,9.235269114469526,6.2572013784811364,6,2.833333333333333,-56.15940855948922,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.4917765581546286,0.06915479493754112,0.0,-0.5238329238329238,5,12.0,5,5,5,5
MAX_PATH_SUM_BT,9.29502942376682,6.257238670485481,6,2.833333333333333,-9.747450056302576,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.2630958806807077,0.3617638718639669,0.0,-0.5238329238329238,24,18.0,6,6,6,6
MAX_PATH_SUM_BT,9.359113378007736,6.256982793130067,6,2.833333333333333,-192.12788339701493,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.01787020759864554,-1.6459597163547035,0.0,-0.5238329238329238,23,2.0,7,7,7,7
MAX_PATH_SUM_BT,9.379303528417582,6.257098850737611,6,2.833333333333333,-95.26958193269978,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.059390056417978176,-0.7353218997240195,0.0,-0.5238329238329238,33,6.0,8,9,8,8
MAX_PATH_SUM_BT,9.645372595847704,6.2572429209169105,6,2.769230769230769,91.43248259180031,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",1.0775383108402703,0.3951145817312895,0.0,-0.5778869778869781,13,29.0,9,8,9,9
MAX_PATH_SUM_BT,9.735395254222494,6.2571618533400475,6,2.769230769230769,53.65964625959862,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",1.4220218442627308,-0.2409764316575729,0.0,-0.5778869778869781,31,24.0,10,10,11,11
MAX_PATH_SUM_BT,9.571591676117317,6.257366470962711,6,2.833333333333333,169.9029267467869,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.7952059248973024,1.364541285711354,0.0,-0.5238329238329238,15,32.0,11,11,10,10
MAX_PATH_SUM_BT,9.593335348642217,6.257191207492743,6,2.833333333333333,38.62406004008665,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",0.8784109454575124,-0.010651146775805993,0.0,-0.5238329238329238,28,21.0,12,12,12,12
MAX_PATH_SUM_BT,9.202258057612195,6.311333206000482,6,3.333333333333333,42429.603538553456,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.6180977056692901,424.8107143158922,0.0,-0.10221130221130212,3,37.0,13,13,13,13
MAX_PATH_SUM_BT,9.222704588472352,6.311642538707305,6,3.333333333333333,42678.18736144208,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.53985636816496,427.23787154165024,0.0,-0.10221130221130212,21,38.0,14,14,14,14
MAX_PATH_SUM_BT,9.164726148898405,6.257171876073802,6,3.4545454545454546,-73.36226246987792,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.7617184869617875,-0.16233375947743858,0.0,0.0,16,8.0,15,15,15,15
MAX_PATH_SUM_BT,9.156755951302305,6.2571791828700905,6,3.4615384615384617,-69.6216217428971,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.7922174955397114,-0.10500149872259036,0.0,0.005896805896805979,14,9.0,16,16,16,16
MAX_PATH_SUM_BT,9.307298222191967,6.2571669252990745,6,3.4545454545454546,-36.329044686228855,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.2161477110904824,-0.20117966354442668,0.0,0.0,34,16.0,17,17,17,17
MAX_PATH_SUM_BT,9.359432594799202,6.257343002559294,6,3.4545454545454546,116.79116046850092,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float(""-inf"")\n\n        def postorder(root):\n            if not root:  return 0\n\n            left_val, right_val = max(0, postorder(root.left)), max(0, postorder(root.right))\n            ans = max(ans, (root.val + left_val + right_val))\n            return max((root.val + left_val), (root.val + right_val))\n\n        postorder(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.0166486825932993,1.1803981166299835,0.0,0.0,1,31.0,18,18,18,18
MAX_PATH_SUM_BT,9.425078863551738,6.257068668695718,6,3.4615384615384617,-79.32782115291519,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.2345553922933199,-0.9721431586975448,0.0,0.005896805896805979,32,7.0,19,19,19,19
MAX_PATH_SUM_BT,9.482878024589779,6.257075895458825,6,3.4615384615384617,-57.0691861035178,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.4557314782109789,-0.9154388726418152,0.0,0.005896805896805979,26,11.0,20,20,20,20
MAX_PATH_SUM_BT,9.49534863625485,6.25693278167778,6,3.4615384615384617,-165.78337053089788,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5034519126868999,-2.0383710427725563,0.0,0.005896805896805979,8,3.0,21,21,21,21
MAX_PATH_SUM_BT,9.500101493724204,6.2571960653557275,6,3.4615384615384617,42.16436446442642,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5216393464336344,0.027465731870635404,0.0,0.005896805896805979,17,22.0,22,22,23,23
MAX_PATH_SUM_BT,9.316034780268383,6.257212626593933,7,3.3,20.52155194583329,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.1827161234163605,0.15741231718030851,1.0,-0.13031941031941052,12,19.0,23,24,22,22
MAX_PATH_SUM_BT,9.586276149701641,6.25704065414837,6,3.4615384615384617,-55.0460427196217,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.8513979929621739,-1.1919573248662505,0.0,0.005896805896805979,35,13.0,24,23,24,24
MAX_PATH_SUM_BT,9.606314669219449,6.257127847653695,7,3.3,37.309916424838974,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",0.928078021442467,-0.5077996466737552,1.0,-0.13031941031941052,30,20.0,25,25,25,25
MAX_PATH_SUM_BT,9.256639728599401,6.257276842209758,6,4.0,58.375171813038065,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        answer =  - sys.maxsize - 1\n        def dfs(node):\n            if not node:\n                return 0\n            left_sub_tree = dfs(node.left)\n            right_sub_tree = dfs(node.right)\n            answer = max(answer , left_sub_tree + right_sub_tree + node.val)\n            return max(0 , node.val + max(left_sub_tree , right_sub_tree))\n        dfs(root)\n        return answer\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.4099990945718725,0.661275609083855,0.0,0.45995085995086,2,27.0,26,26,26,26
MAX_PATH_SUM_BT,9.082063520517591,6.257192564944179,6,4.230769230769232,-48.12556964722306,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",-1.0780378983266106,0.0,0.0,0.6545454545454547,9,15.0,27,27,27,27
MAX_PATH_SUM_BT,9.259923922808177,6.2568851987325145,6,4.181818181818182,-240.3167124176623,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.39743169380956,-2.41172726045336,0.0,0.6132678132678132,18,1.0,28,28,28,28
MAX_PATH_SUM_BT,9.195464319987217,6.257165498633182,11,3.2352941176470584,46.21138724823899,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.6440948355524587,-0.2123738966474559,5.0,-0.1848822084116202,19,23.0,29,30,30,30
MAX_PATH_SUM_BT,9.275933260051113,6.257258595876031,6,4.181818181818182,57.26135518431037,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.3361698608359381,0.5181070408361507,0.0,0.6132678132678132,36,25.0,30,29,29,29
MAX_PATH_SUM_BT,9.533709971874476,6.257232395461107,6,4.230769230769232,112.74850175790877,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",0.6502466050413129,0.3125273365253757,0.0,0.6545454545454547,27,30.0,31,31,31,31
MAX_PATH_SUM_BT,9.570795943598217,6.2572026391633235,11,3.2352941176470584,183.07262568191243,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.7921609498345045,0.07904664864905614,5.0,-0.1848822084116202,37,33.0,32,32,34,34
MAX_PATH_SUM_BT,9.36378333589442,6.257203074752438,7,4.038461538461538,57.86561140376392,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",0.0,0.08246446784599304,1.0,0.4923832923832923,11,26.0,33,33,32,32
MAX_PATH_SUM_BT,9.505506576642068,6.256899287174237,7,4.038461538461538,-139.8249696882157,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5423226065772682,-2.3011832980067544,1.0,0.4923832923832923,29,5.0,34,34,33,33
MAX_PATH_SUM_BT,9.33889348346457,6.283940857486535,8,4.25,21064.253493960783,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.09524429145051533,209.8785873228149,2.0,0.6707616707616708,7,35.0,35,35,35,35
MAX_PATH_SUM_BT,9.4981702172337,6.2843636386909525,8,4.25,21441.69778010852,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5142490631263565,213.1959101683596,2.0,0.6707616707616708,25,36.0,36,36,36,36
MAX_PATH_SUM_BT,9.368310022004316,6.256989746970456,8,5.4375,-24.234891857880587,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",0.017321959315383897,-1.591396899121855,2.0,1.6721130221130225,22,17.0,37,37,37,37
MAX_PATH_SUM_BT,9.398064363318838,6.257334004916799,8,5.4375,254.42409042578163,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",0.13118085679440766,1.1097987506054992,2.0,1.6721130221130225,4,34.0,38,38,38,38
