Label,Time,Space,Cyclomatic,Halstead,Composite Metric,Code,Scaled_Time,Scaled_Space,Scaled_Cyclomatic,Scaled_Halstead,Index,Model_Rank
MAX_PATH_SUM_BT,9.359432594799204,6.257343002559292,6,3.4545454545454546,116.79116046850093,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float(""-inf"")\n\n        def postorder(root):\n            if not root:  return 0\n\n            left_val, right_val = max(0, postorder(root.left)), max(0, postorder(root.right))\n            ans = max(ans, (root.val + left_val + right_val))\n            return max((root.val + left_val), (root.val + right_val))\n\n        postorder(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.0166486825932993,1.1803981166299837,0.0,0.0,1,31.0
MAX_PATH_SUM_BT,9.256639728599401,6.257276842209757,6,4.0,58.37517181303806,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        answer =  - sys.maxsize - 1\n        def dfs(node):\n            if not node:\n                return 0\n            left_sub_tree = dfs(node.left)\n            right_sub_tree = dfs(node.right)\n            answer = max(answer , left_sub_tree + right_sub_tree + node.val)\n            return max(0 , node.val + max(left_sub_tree , right_sub_tree))\n        dfs(root)\n        return answer\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.4099990945718725,0.661275609083855,0.0,0.45995085995086,2,27.0
MAX_PATH_SUM_BT,9.202258057612193,6.311333206000482,6,3.3333333333333335,42429.603538553456,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.6180977056692901,424.8107143158922,0.0,-0.10221130221130213,3,37.0
MAX_PATH_SUM_BT,9.398064363318838,6.257334004916799,8,5.4375,254.42409042578163,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",0.13118085679440766,1.1097987506054992,2.0,1.6721130221130225,4,34.0
MAX_PATH_SUM_BT,9.235269114469526,6.257201378481136,6,2.8333333333333335,-56.15940855948922,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.4917765581546286,0.06915479493754113,0.0,-0.5238329238329238,5,12.0
MAX_PATH_SUM_BT,9.212762633378025,6.257196156359804,6,2.8333333333333335,-66.71620974587103,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.577900565946395,0.02817978891754788,0.0,-0.5238329238329238,6,10.0
MAX_PATH_SUM_BT,9.33889348346457,6.2839408574865345,8,4.25,21064.253493960783,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.09524429145051531,209.8785873228149,2.0,0.6707616707616708,7,35.0
MAX_PATH_SUM_BT,9.49534863625485,6.25693278167778,6,3.4615384615384617,-165.78337053089786,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5034519126868999,-2.0383710427725563,0.0,0.005896805896805979,8,3.0
MAX_PATH_SUM_BT,9.082063520517591,6.257192564944179,6,4.230769230769231,-48.12556964722306,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",-1.0780378983266106,0.0,0.0,0.6545454545454547,9,15.0
MAX_PATH_SUM_BT,9.063347481874139,6.257146557337214,6,2.8333333333333335,-148.51548588901875,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",-1.1496572799352445,-0.36099543702229236,0.0,-0.5238329238329238,10,4.0
MAX_PATH_SUM_BT,9.363783335894421,6.257203074752438,7,4.038461538461538,57.865611403763914,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",0.0,0.08246446784599304,1.0,0.4923832923832923,11,26.0
MAX_PATH_SUM_BT,9.316034780268382,6.257212626593933,7,3.3,20.521551945833288,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.1827161234163605,0.15741231718030851,1.0,-0.13031941031941052,12,19.0
MAX_PATH_SUM_BT,9.645372595847704,6.25724292091691,6,2.769230769230769,91.43248259180031,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",1.0775383108402703,0.3951145817312895,0.0,-0.5778869778869781,13,29.0
MAX_PATH_SUM_BT,9.156755951302303,6.2571791828700905,6,3.4615384615384617,-69.6216217428971,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.7922174955397114,-0.10500149872259036,0.0,0.005896805896805979,14,9.0
MAX_PATH_SUM_BT,9.571591676117315,6.257366470962711,6,2.8333333333333335,169.9029267467869,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.7952059248973024,1.3645412857113541,0.0,-0.5238329238329238,15,32.0
MAX_PATH_SUM_BT,9.164726148898405,6.257171876073802,6,3.4545454545454546,-73.36226246987792,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.7617184869617875,-0.16233375947743858,0.0,0.0,16,8.0
MAX_PATH_SUM_BT,9.500101493724204,6.257196065355728,6,3.4615384615384617,42.16436446442642,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5216393464336344,0.027465731870635404,0.0,0.005896805896805979,17,22.0
MAX_PATH_SUM_BT,9.259923922808177,6.2568851987325145,6,4.181818181818182,-240.3167124176623,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.39743169380956,-2.4117272604533597,0.0,0.6132678132678132,18,1.0
MAX_PATH_SUM_BT,9.195464319987215,6.257165498633183,11,3.235294117647059,46.21138724823899,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.6440948355524587,-0.2123738966474559,5.0,-0.1848822084116202,19,23.0
MAX_PATH_SUM_BT,9.347384477537839,6.257136937391685,8,2.1818181818181817,-52.015128648317216,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.06275238670747871,-0.4364776598432264,2.0,-1.0732186732186735,20,14.0
MAX_PATH_SUM_BT,9.222704588472352,6.311642538707305,6,3.3333333333333335,42678.187361442084,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.53985636816496,427.23787154165024,0.0,-0.10221130221130213,21,38.0
MAX_PATH_SUM_BT,9.368310022004316,6.256989746970456,8,5.4375,-24.234891857880584,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(""-inf"")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n",0.017321959315383897,-1.591396899121855,2.0,1.6721130221130225,22,17.0
MAX_PATH_SUM_BT,9.359113378007736,6.256982793130067,6,2.8333333333333335,-192.12788339701495,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.017870207598645535,-1.6459597163547037,0.0,-0.5238329238329238,23,2.0
MAX_PATH_SUM_BT,9.295029423766819,6.25723867048548,6,2.8333333333333335,-9.747450056302576,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.26309588068070766,0.36176387186396686,0.0,-0.5238329238329238,24,18.0
MAX_PATH_SUM_BT,9.498170217233701,6.284363638690953,8,4.25,21441.697780108516,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5142490631263565,213.19591016835957,2.0,0.6707616707616708,25,36.0
MAX_PATH_SUM_BT,9.48287802458978,6.257075895458824,6,3.4615384615384617,-57.0691861035178,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n",0.4557314782109789,-0.9154388726418152,0.0,0.005896805896805979,26,11.0
MAX_PATH_SUM_BT,9.533709971874476,6.257232395461106,6,4.230769230769231,112.74850175790877,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",0.6502466050413129,0.3125273365253757,0.0,0.6545454545454547,27,30.0
MAX_PATH_SUM_BT,9.593335348642217,6.257191207492743,6,2.8333333333333335,38.62406004008665,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n",0.8784109454575124,-0.010651146775805993,0.0,-0.5238329238329238,28,21.0
MAX_PATH_SUM_BT,9.505506576642068,6.256899287174237,7,4.038461538461538,-139.8249696882157,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(""-inf"")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(""-inf"")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(""-inf"") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n",0.5423226065772682,-2.3011832980067544,1.0,0.4923832923832923,29,5.0
MAX_PATH_SUM_BT,9.60631466921945,6.257127847653695,7,3.3,37.309916424838974,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n",0.928078021442467,-0.5077996466737552,1.0,-0.13031941031941052,30,20.0
MAX_PATH_SUM_BT,9.735395254222494,6.257161853340047,6,2.769230769230769,53.65964625959862,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n",1.4220218442627308,-0.24097643165757288,0.0,-0.5778869778869781,31,24.0
MAX_PATH_SUM_BT,9.425078863551738,6.257068668695717,6,3.4615384615384617,-79.32782115291518,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.2345553922933199,-0.9721431586975448,0.0,0.005896805896805979,32,7.0
MAX_PATH_SUM_BT,9.379303528417582,6.257098850737611,6,2.8333333333333335,-95.26958193269978,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.05939005641797818,-0.7353218997240195,0.0,-0.5238329238329238,33,6.0
MAX_PATH_SUM_BT,9.307298222191966,6.2571669252990745,6,3.4545454545454546,-36.329044686228855,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore ""left"" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore ""right"" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.21614771109048242,-0.20117966354442668,0.0,0.0,34,16.0
MAX_PATH_SUM_BT,9.58627614970164,6.25704065414837,6,3.4615384615384617,-55.046042719621695,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",0.8513979929621739,-1.1919573248662503,0.0,0.005896805896805979,35,13.0
MAX_PATH_SUM_BT,9.275933260051112,6.2572585958760305,6,4.181818181818182,57.26135518431037,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n",-0.3361698608359381,0.5181070408361507,0.0,0.6132678132678132,36,25.0
MAX_PATH_SUM_BT,9.570795943598217,6.257202639163324,11,3.235294117647059,183.07262568191243,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n",0.7921609498345045,0.07904664864905614,5.0,-0.1848822084116202,37,33.0
MAX_PATH_SUM_BT,9.573824004206307,6.257230247074929,8,2.1818181818181817,86.18720058768588,"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n		## TIME COMPLEXITY : O(N) ##\n		## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n",0.8037482217116501,0.2956701762024578,2.0,-1.0732186732186735,38,28.0
